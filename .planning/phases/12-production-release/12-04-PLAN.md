---
phase: 12-production-release
plan: 04
type: execute
wave: 3
depends_on: ["01", "02", "03"]
files_modified:
  - src/index.ts
  - src/services/ai/AIServiceFactory.ts
  - src/infrastructure/cache/ResourceCache.ts
  - src/services/RoadmapPlanningService.ts
  - src/services/IssueTriagingService.ts
  - src/infrastructure/persistence/FilePersistenceAdapter.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All 119 registered tools have working handlers in index.ts"
    - "JSON.parse calls are wrapped in try-catch with proper error handling"
    - "ResourceCache cleans up intervals on process signals"
    - "No syntax errors in production code"
  artifacts:
    - path: "src/index.ts"
      provides: "Complete tool handler switch statement"
      contains: "case \"health_check\""
    - path: "src/infrastructure/cache/ResourceCache.ts"
      provides: "Proper interval cleanup"
      contains: "process.on('SIGTERM'"
  key_links:
    - from: "src/index.ts"
      to: "src/infrastructure/tools/*-tools.ts"
      via: "executor imports"
      pattern: "execute.*Tool"
---

<objective>
Fix all critical functional and technical gaps identified in code review before production release.

Purpose: Close gaps identified by critic, arbiter, and architect agents to ensure production readiness.

Output: All 119 tools working, error handling improved, resource leaks fixed.
</objective>

<context>
Critical issues identified by code review:
1. 15 tools registered but missing handlers in index.ts
2. health_check and create_project_field handlers missing
3. JSON.parse without try-catch in multiple files
4. ResourceCache setInterval not cleaned on process exit
5. Syntax error in AIServiceFactory.ts:382
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix syntax error in AIServiceFactory</name>
  <files>src/services/ai/AIServiceFactory.ts</files>
  <action>
Fix the double closing brace syntax error at line 382.

The error is:
```typescript
results.anthropic = true;
}        } catch (error) {  // ‚Üê Double closing brace
```

Should be:
```typescript
results.anthropic = true;
      } catch (error) {
```

Verify the file compiles after fix.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no errors
2. File has proper brace matching
  </verify>
  <done>AIServiceFactory.ts syntax error fixed</done>
</task>

<task type="auto">
  <name>Task 2: Add missing tool handler imports to index.ts</name>
  <files>src/index.ts</files>
  <action>
Add imports for the missing tool executors. These executors exist but are not imported:

```typescript
// Add to existing imports section (around line 29-56)

// Phase 8 - Project Lifecycle Tools
import {
  executeCloseProject,
  executeReopenProject,
  executeConvertDraftIssue,
} from "./infrastructure/tools/project-lifecycle-tools.js";

// Phase 8 - Project Advanced Tools
import {
  executeUpdateItemPosition,
  executeSearchIssuesAdvanced,
  executeFilterProjectItems,
} from "./infrastructure/tools/project-advanced-tools.js";

// Phase 10 - Sprint AI Tools
import {
  executeCalculateSprintCapacity,
  executePrioritizeBacklog,
  executeAssessSprintRisk,
  executeSuggestSprintComposition,
} from "./infrastructure/tools/sprint-ai-tools.js";

// Phase 10 - Roadmap AI Tools
import {
  executeGenerateAIRoadmap,
  executeGenerateRoadmapVisualization,
} from "./infrastructure/tools/roadmap-ai-tools.js";

// Phase 11 - Issue Intelligence Tools
import {
  executeEnrichIssue,
  executeSuggestLabels,
  executeDetectDuplicates,
  executeFindRelatedIssues,
} from "./infrastructure/tools/issue-intelligence-tools.js";

// Health Tools
import { executeHealthCheck } from "./infrastructure/tools/health-tools.js";
```

Verify imports resolve correctly.
  </action>
  <verify>
1. All import paths are valid
2. No TypeScript errors on imports
  </verify>
  <done>Missing tool executor imports added to index.ts</done>
</task>

<task type="auto">
  <name>Task 3: Add missing case handlers to executeToolHandler</name>
  <files>src/index.ts</files>
  <action>
Add case handlers for the 17 missing tools in the executeToolHandler switch statement (before the default case around line 689).

```typescript
// Phase 8 - Project Lifecycle
case "close_project":
  return await executeCloseProject(args);

case "reopen_project":
  return await executeReopenProject(args);

case "convert_draft_issue":
  return await executeConvertDraftIssue(args);

// Phase 8 - Advanced Operations
case "update_item_position":
  return await executeUpdateItemPosition(args);

case "search_issues_advanced":
  return await executeSearchIssuesAdvanced(args);

case "filter_project_items":
  return await executeFilterProjectItems(args);

// Phase 10 - Sprint AI
case "calculate_sprint_capacity":
  return await executeCalculateSprintCapacity(args);

case "prioritize_backlog":
  return await executePrioritizeBacklog(args);

case "assess_sprint_risk":
  return await executeAssessSprintRisk(args);

case "suggest_sprint_composition":
  return await executeSuggestSprintComposition(args);

// Phase 10 - Roadmap AI
case "generate_ai_roadmap":
  return await executeGenerateAIRoadmap(args);

case "generate_roadmap_visualization":
  return await executeGenerateRoadmapVisualization(args);

// Phase 11 - Issue Intelligence
case "enrich_issue":
  return await executeEnrichIssue(args);

case "suggest_labels":
  return await executeSuggestLabels(args);

case "detect_duplicates":
  return await executeDetectDuplicates(args);

case "find_related_issues":
  return await executeFindRelatedIssues(args);

// Health
case "health_check":
  return await executeHealthCheck(args);
```

Also add handler for create_project_field if missing.
  </action>
  <verify>
1. Count case statements matches 119 tools
2. No duplicate case labels
3. TypeScript compiles without errors
  </verify>
  <done>All 119 tools have handlers in executeToolHandler</done>
</task>

<task type="auto">
  <name>Task 4: Add try-catch to JSON.parse in RoadmapPlanningService</name>
  <files>src/services/RoadmapPlanningService.ts</files>
  <action>
Wrap the JSON.parse call around line 178 in a try-catch block:

```typescript
// Before
const jsonMatch = response.text.match(/\{[\s\S]*\}/);
if (!jsonMatch) {
  throw new Error('Failed to parse AI response for roadmap');
}
return JSON.parse(jsonMatch[0]);

// After
const jsonMatch = response.text.match(/\{[\s\S]*\}/);
if (!jsonMatch) {
  throw new Error('Failed to extract JSON from AI response for roadmap');
}

try {
  return JSON.parse(jsonMatch[0]);
} catch (parseError) {
  const message = parseError instanceof Error ? parseError.message : String(parseError);
  throw new Error(`Failed to parse roadmap JSON: ${message}`);
}
```
  </action>
  <verify>
1. JSON.parse is wrapped in try-catch
2. Error message is descriptive
  </verify>
  <done>RoadmapPlanningService JSON.parse has error handling</done>
</task>

<task type="auto">
  <name>Task 5: Add try-catch to JSON.parse in IssueTriagingService</name>
  <files>src/services/IssueTriagingService.ts</files>
  <action>
Wrap the JSON.parse call around line 65 in a try-catch block with descriptive error message.

Follow the same pattern as Task 4.
  </action>
  <verify>
1. JSON.parse is wrapped in try-catch
2. Error message is descriptive
  </verify>
  <done>IssueTriagingService JSON.parse has error handling</done>
</task>

<task type="auto">
  <name>Task 6: Add try-catch to JSON.parse in FilePersistenceAdapter</name>
  <files>src/infrastructure/persistence/FilePersistenceAdapter.ts</files>
  <action>
Wrap JSON.parse calls at lines 60, 324, and 361 in try-catch blocks.

For each occurrence:
```typescript
try {
  const data = JSON.parse(content);
  // ... rest of logic
} catch (parseError) {
  const message = parseError instanceof Error ? parseError.message : String(parseError);
  // Log and handle gracefully - don't crash on corrupted cache
  process.stderr.write(`[FilePersistenceAdapter] Failed to parse JSON: ${message}\n`);
  return defaultValue; // or throw with context
}
```

For cache loading, return empty/default state rather than crashing.
  </action>
  <verify>
1. All 3 JSON.parse calls wrapped
2. Corrupted cache files don't crash server
  </verify>
  <done>FilePersistenceAdapter JSON.parse has error handling</done>
</task>

<task type="auto">
  <name>Task 7: Add process signal handlers to ResourceCache</name>
  <files>src/infrastructure/cache/ResourceCache.ts</files>
  <action>
Add cleanup on process termination signals in enablePersistence() method (around line 494):

```typescript
enablePersistence(cacheDirectory?: string): void {
  // Clear any existing interval first to prevent duplicates
  if (this.persistInterval) {
    clearInterval(this.persistInterval);
    this.persistInterval = undefined;
  }

  this.persistence = new CachePersistence(cacheDirectory);

  this.persistInterval = setInterval(async () => {
    try {
      await this.persist();
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      process.stderr.write(`[ResourceCache] Periodic persist failed: ${message}\n`);
    }
  }, this.PERSIST_INTERVAL_MS);

  // Register cleanup on process termination
  const cleanup = () => {
    this.shutdown();
    process.exit(0);
  };

  process.once('SIGTERM', cleanup);
  process.once('SIGINT', cleanup);
}
```

Also ensure shutdown() properly clears the interval:
```typescript
public shutdown(): void {
  if (this.persistInterval) {
    clearInterval(this.persistInterval);
    this.persistInterval = undefined;
  }
  // ... rest of shutdown logic
}
```
  </action>
  <verify>
1. enablePersistence clears existing interval before creating new one
2. SIGTERM and SIGINT handlers registered
3. shutdown() clears interval
  </verify>
  <done>ResourceCache properly cleans up on process exit</done>
</task>

<task type="auto">
  <name>Task 8: Verify all tools work with build test</name>
  <files>build/</files>
  <action>
Run build and verify no TypeScript errors:

```bash
npm run build
```

Then run a quick smoke test to verify tools are registered:

```bash
# Count registered tools
node -e "
import('./build/infrastructure/tools/ToolRegistry.js').then(m => {
  const registry = m.ToolRegistry.getInstance();
  console.log('Registered tools:', registry.getTools().length);
});
"
```

Expected: 119 tools registered.
  </action>
  <verify>
1. Build completes without errors
2. 119 tools registered
  </verify>
  <done>Build succeeds and all 119 tools are registered</done>
</task>

<task type="auto">
  <name>Task 9: Run test suite to verify no regressions</name>
  <files>tests/</files>
  <action>
Run the full test suite:

```bash
npm test
```

Verify:
- No new test failures introduced
- Existing tests still pass
  </action>
  <verify>
1. Test suite passes (allowing pre-existing skips)
2. No new failures from gap closure changes
  </verify>
  <done>Test suite passes with no regressions</done>
</task>

</tasks>

<verification>
```bash
# Verify syntax - no TypeScript errors
npx tsc --noEmit

# Verify build
npm run build

# Count tool handlers in index.ts
grep -c "case \"" src/index.ts

# Verify JSON.parse safety
grep -B2 "JSON.parse" src/services/RoadmapPlanningService.ts | grep -q "try"
grep -B2 "JSON.parse" src/services/IssueTriagingService.ts | grep -q "try"

# Verify ResourceCache cleanup
grep "SIGTERM" src/infrastructure/cache/ResourceCache.ts

# Run tests
npm test
```
</verification>

<success_criteria>
1. All 119 tools have working handlers
2. No TypeScript compilation errors
3. JSON.parse calls have error handling
4. ResourceCache cleans up on process exit
5. Test suite passes
6. Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-production-release/12-04-SUMMARY.md`
</output>
