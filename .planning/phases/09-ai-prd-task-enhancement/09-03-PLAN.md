---
phase: 09-ai-prd-task-enhancement
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/services/PRDGenerationService.ts
  - src/services/TaskGenerationService.ts
  - src/services/ai/AITaskProcessor.ts
  - src/analysis/DependencyGraph.ts
  - src/analysis/EstimationCalibrator.ts
autonomous: true

must_haves:
  truths:
    - "PRD generation includes per-section confidence scores"
    - "Task generation includes effort estimates in story points"
    - "Dependencies are detected via graph analysis"
    - "Low confidence triggers clarifying question generation"
  artifacts:
    - path: "src/services/PRDGenerationService.ts"
      provides: "Confidence-aware PRD generation"
      contains: "sectionConfidence"
    - path: "src/services/TaskGenerationService.ts"
      provides: "Effort estimation and dependency detection"
      contains: "effortEstimate"
    - path: "src/analysis/DependencyGraph.ts"
      provides: "Graph-based dependency analysis"
      exports: ["DependencyGraph", "detectImplicitDependencies"]
    - path: "src/analysis/EstimationCalibrator.ts"
      provides: "Estimation calibration with historical data"
      exports: ["EstimationCalibrator"]
  key_links:
    - from: "src/services/PRDGenerationService.ts"
      to: "src/services/ai/ConfidenceScorer.ts"
      via: "confidence scoring integration"
      pattern: "ConfidenceScorer"
    - from: "src/services/TaskGenerationService.ts"
      to: "src/analysis/DependencyGraph.ts"
      via: "dependency detection"
      pattern: "DependencyGraph"
---

<objective>
Integrate confidence scoring into PRD/task generation and add dependency graph analysis.

Purpose: Enhance AI-generated content with actionable confidence signals, graph-based dependency detection, and calibrated effort estimation to improve planning accuracy and identify areas needing human review.

Output: Modified PRD and task generation services with confidence integration, new dependency analysis module, and estimation calibration service.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-prd-task-enhancement/09-01-SUMMARY.md
@src/services/PRDGenerationService.ts
@src/services/TaskGenerationService.ts
@src/services/ai/AITaskProcessor.ts
@src/services/ai/ConfidenceScorer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dependency graph analysis module</name>
  <files>src/analysis/DependencyGraph.ts, src/analysis/KeywordExtractor.ts</files>
  <action>
First, install graphlib:
```bash
npm install graphlib @types/graphlib
```

Create directory:
```bash
mkdir -p src/analysis
```

Create src/analysis/KeywordExtractor.ts:

```typescript
/**
 * Keyword patterns for detecting task dependencies
 */
interface DependencyPattern {
  keywords: string[];
  dependsOn: string[];  // Keywords this pattern typically depends on
  confidence: number;   // How confident we are in this pattern (0-1)
}

/**
 * Common dependency patterns in software development
 */
const DEPENDENCY_PATTERNS: DependencyPattern[] = [
  // Infrastructure/setup tasks
  {
    keywords: ['setup', 'infrastructure', 'init', 'configure', 'scaffold'],
    dependsOn: [],
    confidence: 0.9
  },
  // Database/schema tasks
  {
    keywords: ['database', 'schema', 'model', 'migration', 'db'],
    dependsOn: ['setup', 'infrastructure'],
    confidence: 0.85
  },
  // API/backend tasks
  {
    keywords: ['api', 'endpoint', 'route', 'controller', 'service', 'backend'],
    dependsOn: ['database', 'schema', 'model'],
    confidence: 0.8
  },
  // Frontend/UI tasks
  {
    keywords: ['ui', 'frontend', 'component', 'page', 'view', 'interface'],
    dependsOn: ['api', 'endpoint'],
    confidence: 0.75
  },
  // Integration tasks
  {
    keywords: ['integration', 'connect', 'wire', 'link'],
    dependsOn: ['api', 'ui', 'frontend', 'backend'],
    confidence: 0.7
  },
  // Testing tasks
  {
    keywords: ['test', 'testing', 'unit', 'integration', 'e2e', 'spec'],
    dependsOn: ['implement', 'create', 'build'],
    confidence: 0.85
  },
  // Documentation tasks
  {
    keywords: ['document', 'docs', 'readme', 'documentation'],
    dependsOn: ['implement', 'create', 'test'],
    confidence: 0.7
  },
  // Deployment tasks
  {
    keywords: ['deploy', 'release', 'publish', 'ship'],
    dependsOn: ['test', 'testing', 'documentation'],
    confidence: 0.9
  }
];

/**
 * Extract keywords from task title and description
 */
export function extractKeywords(text: string): string[] {
  const normalized = text.toLowerCase();

  // Remove common stop words
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
    'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
    'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
    'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
    'this', 'that', 'these', 'those', 'it', 'its', 'which', 'who', 'whom',
    'what', 'when', 'where', 'why', 'how', 'all', 'each', 'every', 'both',
    'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not',
    'only', 'own', 'same', 'so', 'than', 'too', 'very'
  ]);

  // Extract words
  const words = normalized
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(w => w.length > 2 && !stopWords.has(w));

  return [...new Set(words)];
}

/**
 * Find matching dependency pattern for keywords
 */
export function findMatchingPattern(keywords: string[]): DependencyPattern | null {
  for (const pattern of DEPENDENCY_PATTERNS) {
    const matchCount = pattern.keywords.filter(k =>
      keywords.some(kw => kw.includes(k) || k.includes(kw))
    ).length;

    if (matchCount > 0) {
      return pattern;
    }
  }
  return null;
}

/**
 * Check if task B likely depends on task A based on keywords
 */
export function checkKeywordDependency(
  taskAKeywords: string[],
  taskBKeywords: string[]
): { likely: boolean; confidence: number; reason: string } {
  const patternB = findMatchingPattern(taskBKeywords);

  if (!patternB) {
    return { likely: false, confidence: 0, reason: 'No pattern match' };
  }

  // Check if task A matches any of B's dependency patterns
  const matchingDeps = patternB.dependsOn.filter(dep =>
    taskAKeywords.some(kw => kw.includes(dep) || dep.includes(kw))
  );

  if (matchingDeps.length > 0) {
    return {
      likely: true,
      confidence: patternB.confidence * (matchingDeps.length / patternB.dependsOn.length),
      reason: `Task matches dependency pattern: ${matchingDeps.join(', ')}`
    };
  }

  return { likely: false, confidence: 0, reason: 'Keywords do not suggest dependency' };
}

/**
 * Get all dependency patterns for documentation
 */
export function getDependencyPatterns(): DependencyPattern[] {
  return [...DEPENDENCY_PATTERNS];
}
```

Create src/analysis/DependencyGraph.ts:

```typescript
import { Graph, alg } from 'graphlib';
import { AITask, TaskDependency, EnhancedTaskDependency } from '../domain/ai-types';
import { extractKeywords, checkKeywordDependency } from './KeywordExtractor';

/**
 * Detected dependency with confidence
 */
export interface DetectedDependency {
  fromTaskId: string;
  toTaskId: string;
  type: 'blocks' | 'depends_on' | 'related_to';
  confidence: number;
  reasoning: string;
  isImplicit: boolean;  // true if auto-detected, false if explicit
}

/**
 * Graph analysis result
 */
export interface GraphAnalysisResult {
  executionOrder: string[];      // Topological sort order
  criticalPath: string[];        // Longest dependency chain
  parallelGroups: string[][];    // Tasks that can run in parallel
  cycles: string[][];            // Detected circular dependencies
  orphanTasks: string[];         // Tasks with no dependencies (entry points)
  leafTasks: string[];           // Tasks nothing depends on (exit points)
}

/**
 * Graph-based task dependency analysis
 */
export class DependencyGraph {
  private graph: Graph;
  private tasks: Map<string, AITask>;
  private implicitDependencies: DetectedDependency[] = [];

  constructor() {
    this.graph = new Graph({ directed: true });
    this.tasks = new Map();
  }

  /**
   * Add a task to the graph
   */
  addTask(task: AITask): void {
    this.tasks.set(task.id, task);
    this.graph.setNode(task.id, {
      title: task.title,
      complexity: task.complexity
    });

    // Add explicit dependencies
    for (const dep of task.dependencies || []) {
      this.addDependency(dep.id, task.id, {
        type: dep.type,
        confidence: 1.0,
        reasoning: dep.description || 'Explicitly defined',
        isImplicit: false
      });
    }
  }

  /**
   * Add multiple tasks
   */
  addTasks(tasks: AITask[]): void {
    for (const task of tasks) {
      this.addTask(task);
    }
  }

  /**
   * Add a dependency edge
   */
  addDependency(
    fromId: string,
    toId: string,
    meta: { type: string; confidence: number; reasoning: string; isImplicit: boolean }
  ): void {
    this.graph.setEdge(fromId, toId, meta);

    if (meta.isImplicit) {
      this.implicitDependencies.push({
        fromTaskId: fromId,
        toTaskId: toId,
        type: meta.type as 'blocks' | 'depends_on' | 'related_to',
        confidence: meta.confidence,
        reasoning: meta.reasoning,
        isImplicit: true
      });
    }
  }

  /**
   * Detect implicit dependencies using keyword analysis
   */
  detectImplicitDependencies(confidenceThreshold: number = 0.5): DetectedDependency[] {
    const tasks = Array.from(this.tasks.values());
    const detected: DetectedDependency[] = [];

    for (let i = 0; i < tasks.length; i++) {
      for (let j = 0; j < tasks.length; j++) {
        if (i === j) continue;

        const taskA = tasks[i];
        const taskB = tasks[j];

        // Skip if explicit dependency already exists
        if (this.graph.hasEdge(taskA.id, taskB.id)) continue;

        const keywordsA = extractKeywords(`${taskA.title} ${taskA.description}`);
        const keywordsB = extractKeywords(`${taskB.title} ${taskB.description}`);

        const result = checkKeywordDependency(keywordsA, keywordsB);

        if (result.likely && result.confidence >= confidenceThreshold) {
          const dep: DetectedDependency = {
            fromTaskId: taskA.id,
            toTaskId: taskB.id,
            type: 'depends_on',
            confidence: result.confidence,
            reasoning: result.reason,
            isImplicit: true
          };

          detected.push(dep);

          // Add to graph
          this.addDependency(taskA.id, taskB.id, {
            type: 'depends_on',
            confidence: result.confidence,
            reasoning: result.reason,
            isImplicit: true
          });
        }
      }
    }

    this.implicitDependencies.push(...detected);
    return detected;
  }

  /**
   * Detect circular dependencies
   */
  detectCycles(): string[][] {
    try {
      return alg.findCycles(this.graph);
    } catch {
      return [];
    }
  }

  /**
   * Get topological execution order
   */
  getExecutionOrder(): string[] {
    const cycles = this.detectCycles();
    if (cycles.length > 0) {
      throw new Error(`Cannot determine execution order: circular dependencies found in ${cycles.length} cycle(s)`);
    }

    try {
      return alg.topsort(this.graph);
    } catch {
      // If topsort fails, return nodes in arbitrary order
      return this.graph.nodes();
    }
  }

  /**
   * Find the critical path (longest dependency chain)
   */
  getCriticalPath(): string[] {
    const nodes = this.graph.nodes();
    const distances: Map<string, number> = new Map();
    const predecessors: Map<string, string> = new Map();

    // Initialize distances
    for (const node of nodes) {
      distances.set(node, 0);
    }

    // Get topological order
    let order: string[];
    try {
      order = alg.topsort(this.graph);
    } catch {
      return []; // Cycles present
    }

    // Calculate longest paths
    for (const node of order) {
      const task = this.tasks.get(node);
      const nodeWeight = task?.complexity || 1;
      const currentDist = distances.get(node) || 0;

      for (const successor of this.graph.successors(node) || []) {
        const newDist = currentDist + nodeWeight;
        if (newDist > (distances.get(successor) || 0)) {
          distances.set(successor, newDist);
          predecessors.set(successor, node);
        }
      }
    }

    // Find the end of critical path
    let maxDist = 0;
    let endNode = '';
    for (const [node, dist] of distances) {
      if (dist > maxDist) {
        maxDist = dist;
        endNode = node;
      }
    }

    // Reconstruct path
    const path: string[] = [];
    let current = endNode;
    while (current) {
      path.unshift(current);
      current = predecessors.get(current) || '';
    }

    return path;
  }

  /**
   * Group tasks that can run in parallel
   */
  getParallelGroups(): string[][] {
    const groups: string[][] = [];
    const inDegree: Map<string, number> = new Map();
    const nodes = this.graph.nodes();

    // Initialize in-degrees
    for (const node of nodes) {
      inDegree.set(node, (this.graph.predecessors(node) || []).length);
    }

    const remaining = new Set(nodes);

    while (remaining.size > 0) {
      // Find all nodes with no remaining dependencies
      const group: string[] = [];

      for (const node of remaining) {
        if (inDegree.get(node) === 0) {
          group.push(node);
        }
      }

      if (group.length === 0) {
        // Cycle detected or error
        break;
      }

      groups.push(group);

      // Remove these nodes and update in-degrees
      for (const node of group) {
        remaining.delete(node);
        for (const successor of this.graph.successors(node) || []) {
          inDegree.set(successor, (inDegree.get(successor) || 1) - 1);
        }
      }
    }

    return groups;
  }

  /**
   * Get orphan tasks (no predecessors - entry points)
   */
  getOrphanTasks(): string[] {
    return this.graph.nodes().filter(node =>
      (this.graph.predecessors(node) || []).length === 0
    );
  }

  /**
   * Get leaf tasks (no successors - exit points)
   */
  getLeafTasks(): string[] {
    return this.graph.nodes().filter(node =>
      (this.graph.successors(node) || []).length === 0
    );
  }

  /**
   * Run full graph analysis
   */
  analyze(): GraphAnalysisResult {
    const cycles = this.detectCycles();

    let executionOrder: string[] = [];
    let criticalPath: string[] = [];
    let parallelGroups: string[][] = [];

    if (cycles.length === 0) {
      executionOrder = this.getExecutionOrder();
      criticalPath = this.getCriticalPath();
      parallelGroups = this.getParallelGroups();
    }

    return {
      executionOrder,
      criticalPath,
      parallelGroups,
      cycles,
      orphanTasks: this.getOrphanTasks(),
      leafTasks: this.getLeafTasks()
    };
  }

  /**
   * Get all implicit dependencies detected
   */
  getImplicitDependencies(): DetectedDependency[] {
    return [...this.implicitDependencies];
  }

  /**
   * Export graph for visualization
   */
  exportForVisualization(): {
    nodes: Array<{ id: string; label: string; complexity: number }>;
    edges: Array<{ from: string; to: string; type: string; confidence: number }>;
  } {
    const nodes = this.graph.nodes().map(id => {
      const task = this.tasks.get(id);
      return {
        id,
        label: task?.title || id,
        complexity: task?.complexity || 1
      };
    });

    const edges = this.graph.edges().map(e => {
      const edgeData = this.graph.edge(e) || {};
      return {
        from: e.v,
        to: e.w,
        type: edgeData.type || 'depends_on',
        confidence: edgeData.confidence || 1.0
      };
    });

    return { nodes, edges };
  }
}

/**
 * Convenience function to detect dependencies between tasks
 */
export function detectImplicitDependencies(
  tasks: AITask[],
  confidenceThreshold: number = 0.5
): DetectedDependency[] {
  const graph = new DependencyGraph();
  graph.addTasks(tasks);
  return graph.detectImplicitDependencies(confidenceThreshold);
}
```
  </action>
  <verify>
Run: `npm install graphlib @types/graphlib && npx tsc --noEmit`
Verify no TypeScript errors
  </verify>
  <done>
DependencyGraph class exists with addTask, detectImplicitDependencies, analyze methods.
KeywordExtractor provides extractKeywords and checkKeywordDependency for NLP-based detection.
Graph analysis returns executionOrder, criticalPath, parallelGroups, cycles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create estimation calibrator</name>
  <files>src/analysis/EstimationCalibrator.ts</files>
  <action>
Create src/analysis/EstimationCalibrator.ts:

```typescript
import { TaskComplexity } from '../domain/ai-types';

/**
 * Estimation record for tracking accuracy
 */
export interface EstimationRecord {
  taskId: string;
  title: string;
  estimatedPoints: number;
  actualPoints?: number;
  complexityBand: 'low' | 'medium' | 'high';
  estimatedAt: string;
  completedAt?: string;
  tags?: string[];
}

/**
 * Effort estimate with confidence
 */
export interface EffortEstimate {
  points: number;              // Story points (Fibonacci: 1, 2, 3, 5, 8, 13)
  range: {
    low: number;               // Optimistic estimate
    high: number;              // Pessimistic estimate
  };
  confidence: number;          // 0-100 confidence in the estimate
  calibrated: boolean;         // Whether calibration was applied
  calibrationFactor?: number;  // Factor applied if calibrated
  reasoning?: string;
}

/**
 * Complexity band determination
 */
export function getComplexityBand(complexity: TaskComplexity): 'low' | 'medium' | 'high' {
  if (complexity <= 3) return 'low';
  if (complexity <= 6) return 'medium';
  return 'high';
}

/**
 * Map complexity to base story points
 */
export function complexityToPoints(complexity: TaskComplexity): number {
  // Fibonacci-like mapping
  const mapping: Record<TaskComplexity, number> = {
    1: 1,
    2: 1,
    3: 2,
    4: 3,
    5: 5,
    6: 5,
    7: 8,
    8: 8,
    9: 13,
    10: 13
  };
  return mapping[complexity];
}

/**
 * Calculate estimate range based on complexity
 */
export function calculateRange(
  basePoints: number,
  complexity: TaskComplexity
): { low: number; high: number } {
  // Higher complexity = wider range
  const varianceFactor = 1 + (complexity / 10);

  return {
    low: Math.max(1, Math.round(basePoints / varianceFactor)),
    high: Math.round(basePoints * varianceFactor)
  };
}

/**
 * Estimation calibrator with historical accuracy tracking
 */
export class EstimationCalibrator {
  private records: EstimationRecord[] = [];
  private calibrationFactors: Map<string, number> = new Map();

  constructor(historicalRecords?: EstimationRecord[]) {
    if (historicalRecords) {
      this.records = [...historicalRecords];
      this.recalculateFactors();
    }
  }

  /**
   * Record a new estimate
   */
  recordEstimate(params: {
    taskId: string;
    title: string;
    estimatedPoints: number;
    complexity: TaskComplexity;
    tags?: string[];
  }): EstimationRecord {
    const record: EstimationRecord = {
      taskId: params.taskId,
      title: params.title,
      estimatedPoints: params.estimatedPoints,
      complexityBand: getComplexityBand(params.complexity),
      estimatedAt: new Date().toISOString(),
      tags: params.tags
    };

    this.records.push(record);
    return record;
  }

  /**
   * Record actual effort after task completion
   */
  recordActual(taskId: string, actualPoints: number): boolean {
    const record = this.records.find(r => r.taskId === taskId);
    if (!record) return false;

    record.actualPoints = actualPoints;
    record.completedAt = new Date().toISOString();

    // Recalculate calibration factors
    this.recalculateFactors();
    return true;
  }

  /**
   * Recalculate calibration factors from completed records
   */
  private recalculateFactors(): void {
    const bands: Array<'low' | 'medium' | 'high'> = ['low', 'medium', 'high'];

    for (const band of bands) {
      const completed = this.records.filter(
        r => r.actualPoints !== undefined && r.complexityBand === band
      );

      if (completed.length >= 3) {
        // Need at least 3 data points for meaningful calibration
        const ratios = completed.map(r => r.actualPoints! / r.estimatedPoints);

        // Use median ratio to avoid outlier influence
        ratios.sort((a, b) => a - b);
        const medianIndex = Math.floor(ratios.length / 2);
        const medianRatio = ratios.length % 2 === 0
          ? (ratios[medianIndex - 1] + ratios[medianIndex]) / 2
          : ratios[medianIndex];

        this.calibrationFactors.set(band, medianRatio);
      }
    }
  }

  /**
   * Get calibration factor for a complexity band
   */
  getCalibrationFactor(band: 'low' | 'medium' | 'high'): number | null {
    return this.calibrationFactors.get(band) ?? null;
  }

  /**
   * Generate calibrated effort estimate
   */
  estimate(params: {
    complexity: TaskComplexity;
    title?: string;
    description?: string;
    tags?: string[];
  }): EffortEstimate {
    const basePoints = complexityToPoints(params.complexity);
    const band = getComplexityBand(params.complexity);
    const calibrationFactor = this.calibrationFactors.get(band);

    let finalPoints = basePoints;
    let calibrated = false;

    if (calibrationFactor) {
      finalPoints = Math.round(basePoints * calibrationFactor);
      // Clamp to Fibonacci sequence
      finalPoints = this.clampToFibonacci(finalPoints);
      calibrated = true;
    }

    const range = calculateRange(finalPoints, params.complexity);

    // Calculate confidence based on:
    // 1. How much historical data we have
    // 2. How consistent the calibration has been
    const confidence = this.calculateConfidence(band);

    return {
      points: finalPoints,
      range,
      confidence,
      calibrated,
      calibrationFactor,
      reasoning: this.generateReasoning(params.complexity, calibrated, calibrationFactor)
    };
  }

  /**
   * Clamp value to nearest Fibonacci number
   */
  private clampToFibonacci(value: number): number {
    const fibonacci = [1, 2, 3, 5, 8, 13, 21];
    let closest = fibonacci[0];
    let minDiff = Math.abs(value - closest);

    for (const fib of fibonacci) {
      const diff = Math.abs(value - fib);
      if (diff < minDiff) {
        minDiff = diff;
        closest = fib;
      }
    }

    return closest;
  }

  /**
   * Calculate confidence in estimates for a complexity band
   */
  private calculateConfidence(band: 'low' | 'medium' | 'high'): number {
    const completed = this.records.filter(
      r => r.actualPoints !== undefined && r.complexityBand === band
    );

    if (completed.length === 0) return 50;  // No data = 50% confidence
    if (completed.length < 3) return 60;    // Limited data = 60% confidence
    if (completed.length < 10) return 75;   // Some data = 75% confidence

    // Calculate variance in estimate accuracy
    const ratios = completed.map(r => r.actualPoints! / r.estimatedPoints);
    const mean = ratios.reduce((a, b) => a + b, 0) / ratios.length;
    const variance = ratios.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / ratios.length;
    const stdDev = Math.sqrt(variance);

    // Lower variance = higher confidence
    // Perfect accuracy (stdDev = 0) = 95% confidence
    // High variance (stdDev > 1) = 60% confidence
    const confidenceFromVariance = Math.max(60, Math.min(95, 95 - (stdDev * 35)));

    return Math.round(confidenceFromVariance);
  }

  /**
   * Generate reasoning for the estimate
   */
  private generateReasoning(
    complexity: TaskComplexity,
    calibrated: boolean,
    factor?: number | null
  ): string {
    const band = getComplexityBand(complexity);
    const dataCount = this.records.filter(
      r => r.actualPoints !== undefined && r.complexityBand === band
    ).length;

    if (!calibrated) {
      return `Base estimate for complexity ${complexity}/10. No calibration data available.`;
    }

    const direction = factor && factor > 1 ? 'increase' : 'decrease';
    const percent = factor ? Math.round(Math.abs(factor - 1) * 100) : 0;

    return `Calibrated estimate for complexity ${complexity}/10. ` +
      `Historical data (${dataCount} tasks) suggests ${percent}% ${direction} from base.`;
  }

  /**
   * Get estimation accuracy statistics
   */
  getAccuracyStats(): {
    totalRecords: number;
    completedRecords: number;
    accuracyByBand: Record<string, {
      count: number;
      avgError: number;
      calibrationFactor: number | null;
    }>;
  } {
    const bands: Array<'low' | 'medium' | 'high'> = ['low', 'medium', 'high'];
    const accuracyByBand: Record<string, { count: number; avgError: number; calibrationFactor: number | null }> = {};

    for (const band of bands) {
      const completed = this.records.filter(
        r => r.actualPoints !== undefined && r.complexityBand === band
      );

      if (completed.length === 0) {
        accuracyByBand[band] = { count: 0, avgError: 0, calibrationFactor: null };
        continue;
      }

      const errors = completed.map(r =>
        Math.abs(r.actualPoints! - r.estimatedPoints) / r.estimatedPoints
      );
      const avgError = errors.reduce((a, b) => a + b, 0) / errors.length;

      accuracyByBand[band] = {
        count: completed.length,
        avgError: Math.round(avgError * 100) / 100,
        calibrationFactor: this.calibrationFactors.get(band) ?? null
      };
    }

    return {
      totalRecords: this.records.length,
      completedRecords: this.records.filter(r => r.actualPoints !== undefined).length,
      accuracyByBand
    };
  }

  /**
   * Export records for persistence
   */
  exportRecords(): EstimationRecord[] {
    return [...this.records];
  }

  /**
   * Import records from persistence
   */
  importRecords(records: EstimationRecord[]): void {
    this.records = [...records];
    this.recalculateFactors();
  }
}
```
  </action>
  <verify>
Run: `npx tsc --noEmit`
Verify EstimationCalibrator compiles without errors
  </verify>
  <done>
EstimationCalibrator exists with recordEstimate, recordActual, estimate methods.
Complexity bands (low/medium/high) drive calibration factors.
Estimation returns EffortEstimate with points, range, confidence, and calibration info.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate confidence scoring into PRD generation</name>
  <files>src/services/PRDGenerationService.ts, src/services/ai/AITaskProcessor.ts</files>
  <action>
Modify src/services/ai/AITaskProcessor.ts to add confidence-aware generation. Add new imports at the top of the file (after existing imports):

```typescript
// Add these imports at the top of AITaskProcessor.ts, after existing imports
import { v4 as uuidv4 } from 'uuid';
import { generateObject } from 'ai';
import {
  ConfidenceScorer,
  calculateInputCompleteness
} from './ConfidenceScorer';
import {
  CONFIDENCE_PROMPT_CONFIGS,
  AIConfidenceAssessmentSchema,
  withConfidenceAssessment,
  formatPrompt
} from './prompts/ConfidencePrompts';
import {
  SectionConfidence,
  ConfidenceConfig,
  DEFAULT_CONFIDENCE_CONFIG,
  PRDDocument
} from '../../domain/ai-types';
import { PRDDocumentSchema } from '../../domain/ai-types';
import { PRD_PROMPT_CONFIGS } from './prompts/PRDPrompts';
```

Note: Some of these imports may already exist in the file (uuid, generateObject, PRDDocument, PRDDocumentSchema, PRD_PROMPT_CONFIGS). Only add the ones that are missing. The key new imports are:
- `ConfidenceScorer` and `calculateInputCompleteness` from `./ConfidenceScorer`
- `CONFIDENCE_PROMPT_CONFIGS`, `AIConfidenceAssessmentSchema`, `withConfidenceAssessment`, `formatPrompt` from `./prompts/ConfidencePrompts`
- `SectionConfidence`, `ConfidenceConfig`, `DEFAULT_CONFIDENCE_CONFIG` from `../../domain/ai-types`

Add a new property to the AITaskProcessor class:

```typescript
private confidenceScorer: ConfidenceScorer;

constructor() {
  this.aiFactory = AIServiceFactory.getInstance();
  this.confidenceScorer = new ConfidenceScorer();
}
```

Add new method to AITaskProcessor for confidence-aware PRD generation:

```typescript
/**
 * Generate PRD with per-section confidence scoring
 */
async generatePRDWithConfidence(params: {
  projectIdea: string;
  targetUsers?: string;
  timeline?: string;
  complexity?: string;
  confidenceConfig?: Partial<ConfidenceConfig>;
}): Promise<{
  prd: PRDDocument;
  sectionConfidence: SectionConfidence[];
  overallConfidence: { score: number; tier: 'high' | 'medium' | 'low' };
  lowConfidenceSections: SectionConfidence[];
}> {
  const config = { ...DEFAULT_CONFIDENCE_CONFIG, ...params.confidenceConfig };

  // Calculate input completeness
  const inputCompleteness = calculateInputCompleteness({
    description: params.projectIdea,
    context: params.targetUsers,
    constraints: params.timeline ? [params.timeline] : []
  });

  // Generate PRD with confidence request
  const prdConfig = PRD_PROMPT_CONFIGS.generateFromIdea;
  const model = this.getModelWithFallback('prd');

  const prompt = formatPrompt(prdConfig.userPrompt, {
    projectIdea: params.projectIdea,
    targetUsers: params.targetUsers || 'General users',
    timeline: params.timeline || '3-6 months',
    complexity: params.complexity || 'medium'
  }) + CONFIDENCE_PROMPT_CONFIGS.selfAssessmentSuffix;

  // Use schema with confidence assessment
  const PRDWithConfidenceSchema = withConfidenceAssessment(PRDDocumentSchema);

  try {
    const result = await generateObject({
      model,
      system: prdConfig.systemPrompt,
      prompt,
      schema: PRDWithConfidenceSchema,
      maxTokens: prdConfig.maxTokens + 500, // Extra tokens for confidence
      temperature: prdConfig.temperature
    });

    const generated = result.object;
    const aiAssessment = generated.confidenceAssessment;

    // Calculate per-section confidence
    const sectionConfidence: SectionConfidence[] = [];

    // Overview section
    sectionConfidence.push(this.confidenceScorer.calculateSectionConfidence({
      sectionId: 'overview',
      sectionName: 'Overview',
      inputData: { description: params.projectIdea },
      aiSelfAssessment: aiAssessment.score / 100,
      aiReasoning: aiAssessment.reasoning,
      uncertainAreas: aiAssessment.uncertainAreas
    }));

    // Features section
    sectionConfidence.push(this.confidenceScorer.calculateSectionConfidence({
      sectionId: 'features',
      sectionName: 'Features',
      inputData: {
        description: params.projectIdea,
        context: params.targetUsers
      },
      aiSelfAssessment: (aiAssessment.score - 10) / 100, // Features often less certain
      aiReasoning: aiAssessment.reasoning,
      uncertainAreas: aiAssessment.uncertainAreas.filter(a =>
        a.toLowerCase().includes('feature')
      )
    }));

    // Technical requirements section
    sectionConfidence.push(this.confidenceScorer.calculateSectionConfidence({
      sectionId: 'technicalRequirements',
      sectionName: 'Technical Requirements',
      inputData: {
        description: params.projectIdea,
        constraints: params.complexity ? [`Complexity: ${params.complexity}`] : []
      },
      aiSelfAssessment: (aiAssessment.score - 15) / 100, // Tech reqs often assumed
      aiReasoning: aiAssessment.reasoning
    }));

    // Aggregate confidence
    const aggregated = this.confidenceScorer.aggregateConfidence(sectionConfidence);

    // Build PRD without confidence field
    const prd: PRDDocument = {
      ...generated,
      id: uuidv4(),
      aiGenerated: true,
      aiMetadata: this.createAIMetadata(model.modelId, prompt),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    delete (prd as Record<string, unknown>).confidenceAssessment;

    return {
      prd,
      sectionConfidence,
      overallConfidence: {
        score: aggregated.overallScore,
        tier: aggregated.overallTier
      },
      lowConfidenceSections: aggregated.lowConfidenceSections
    };
  } catch (error) {
    process.stderr.write(`Error generating PRD with confidence: ${error instanceof Error ? error.message : String(error)}\n`);
    throw new Error(`Failed to generate PRD: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
```

Modify src/services/PRDGenerationService.ts to add a new public method. Add imports at top:

```typescript
import {
  SectionConfidence,
  ConfidenceConfig
} from '../domain/ai-types';
```

Add new method to PRDGenerationService class:

```typescript
/**
 * Generate PRD with confidence scoring per section
 */
async generatePRDWithConfidence(params: {
  projectIdea: string;
  projectName: string;
  targetUsers?: string[];
  timeline?: string;
  complexity?: 'low' | 'medium' | 'high';
  author: string;
  stakeholders?: string[];
  confidenceConfig?: Partial<ConfidenceConfig>;
}): Promise<{
  prd: PRDDocument;
  sectionConfidence: SectionConfidence[];
  overallConfidence: { score: number; tier: 'high' | 'medium' | 'low' };
  lowConfidenceSections: SectionConfidence[];
}> {
  try {
    if (!params.projectIdea.trim()) {
      throw new Error('Project idea is required');
    }

    if (!params.projectName.trim()) {
      throw new Error('Project name is required');
    }

    const result = await this.aiProcessor.generatePRDWithConfidence({
      projectIdea: params.projectIdea,
      targetUsers: params.targetUsers?.join(', '),
      timeline: params.timeline,
      complexity: params.complexity,
      confidenceConfig: params.confidenceConfig
    });

    // Enhance PRD with provided metadata
    const enhancedPRD: PRDDocument = {
      ...result.prd,
      title: params.projectName,
      author: params.author,
      stakeholders: params.stakeholders || [],
      version: '1.0.0'
    };

    // Validate
    const validatedPRD = PRDDocumentSchema.parse(enhancedPRD);

    return {
      prd: validatedPRD,
      sectionConfidence: result.sectionConfidence,
      overallConfidence: result.overallConfidence,
      lowConfidenceSections: result.lowConfidenceSections
    };
  } catch (error) {
    process.stderr.write(`Error generating PRD with confidence: ${error instanceof Error ? error.message : String(error)}\n`);
    throw new Error(`Failed to generate PRD: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
```
  </action>
  <verify>
Run: `npx tsc --noEmit`
Verify both PRDGenerationService and AITaskProcessor compile without errors
  </verify>
  <done>
AITaskProcessor has generatePRDWithConfidence method that returns PRD with section confidence.
PRDGenerationService exposes generatePRDWithConfidence as public API.
Confidence scoring uses ConfidenceScorer with input completeness + AI self-assessment.
  </done>
</task>

</tasks>

<verification>
1. Run `npm install graphlib @types/graphlib && npx tsc --noEmit` - no errors
2. Verify src/analysis/DependencyGraph.ts exports DependencyGraph and detectImplicitDependencies
3. Verify src/analysis/EstimationCalibrator.ts exports EstimationCalibrator and EffortEstimate
4. Verify PRDGenerationService.generatePRDWithConfidence returns sectionConfidence array
5. Verify AITaskProcessor.generatePRDWithConfidence integrates ConfidenceScorer
</verification>

<success_criteria>
- graphlib installed as dependency
- DependencyGraph.analyze returns execution order, critical path, parallel groups, cycles
- DependencyGraph.detectImplicitDependencies uses keyword extraction
- EstimationCalibrator.estimate returns calibrated story points with confidence
- PRDGenerationService.generatePRDWithConfidence includes per-section confidence
- Low confidence sections include clarifying questions
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-prd-task-enhancement/09-03-SUMMARY.md`
</output>
