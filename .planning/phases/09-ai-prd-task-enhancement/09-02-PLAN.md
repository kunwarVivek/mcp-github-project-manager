---
phase: 09-ai-prd-task-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/services/templates/TemplateEngine.ts
  - src/services/templates/TemplateParser.ts
  - src/services/templates/TemplateValidator.ts
  - src/infrastructure/validation/PRDValidator.ts
  - src/infrastructure/validation/ValidationRuleEngine.ts
  - src/infrastructure/validation/rules/CompletenessRules.ts
  - src/infrastructure/validation/rules/ClarityRules.ts
autonomous: true

must_haves:
  truths:
    - "Templates can be in Markdown, JSON Schema, or example-based format"
    - "Template format is auto-detected from content"
    - "PRD validation checks completeness, clarity, and feasibility"
    - "Validation results include severity and auto-fix suggestions"
  artifacts:
    - path: "src/services/templates/TemplateEngine.ts"
      provides: "Handlebars-based template compilation and rendering"
      exports: ["TemplateEngine"]
    - path: "src/services/templates/TemplateParser.ts"
      provides: "Auto-detection and parsing of template formats"
      exports: ["TemplateParser", "detectTemplateFormat"]
    - path: "src/services/templates/TemplateValidator.ts"
      provides: "Template syntax and coverage validation"
      exports: ["TemplateValidator"]
    - path: "src/infrastructure/validation/PRDValidator.ts"
      provides: "PRD-specific validation rules"
      exports: ["PRDValidator"]
    - path: "src/infrastructure/validation/ValidationRuleEngine.ts"
      provides: "Layered validation rule execution"
      exports: ["ValidationRuleEngine", "ValidationRule"]
  key_links:
    - from: "src/services/templates/TemplateEngine.ts"
      to: "handlebars"
      via: "npm dependency"
      pattern: "import.*Handlebars.*from 'handlebars'"
    - from: "src/infrastructure/validation/PRDValidator.ts"
      to: "src/infrastructure/validation/ValidationRuleEngine.ts"
      via: "rule engine usage"
      pattern: "ValidationRuleEngine"
---

<objective>
Create template system with auto-detection and PRD validation framework.

Purpose: Enable users to provide custom PRD/task templates in multiple formats (Markdown with placeholders, JSON Schema, or example-based), and validate generated PRDs against best practices with severity-based feedback.

Output: Template parsing/rendering engine and layered validation rule system for PRD quality assurance.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-prd-task-enhancement/09-RESEARCH.md
@src/domain/template-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Handlebars and create template engine</name>
  <files>package.json, src/services/templates/TemplateEngine.ts, src/services/templates/TemplateParser.ts</files>
  <action>
First, install Handlebars:
```bash
npm install handlebars
```

Create directory structure if needed:
```bash
mkdir -p src/services/templates
```

Create src/services/templates/TemplateParser.ts:

```typescript
import {
  TemplateFormat,
  TemplateSection,
  ParsedTemplate,
  TemplateValidationResult
} from '../../domain/template-types';

/**
 * Detect template format from content
 *
 * Detection rules:
 * 1. If valid JSON with $schema or type="object" -> json-schema
 * 2. If valid JSON with example/sample fields -> example-based
 * 3. If contains {{placeholders}} -> markdown
 * 4. Default -> example-based (treat as example to learn from)
 */
export function detectTemplateFormat(content: string): TemplateFormat {
  const trimmed = content.trim();

  // Try parsing as JSON first
  try {
    const parsed = JSON.parse(trimmed);

    // Check for JSON Schema indicators
    if (parsed.$schema || parsed.type === 'object' || parsed.properties) {
      return 'json-schema';
    }

    // Check for example-based indicators
    if (parsed.example || parsed.sample || parsed.template?.example) {
      return 'example-based';
    }

    // JSON but not schema or example -> treat as example
    return 'example-based';
  } catch {
    // Not JSON - check for markdown placeholders
    if (/\{\{[^}]+\}\}/.test(trimmed)) {
      return 'markdown';
    }

    // Plain text - treat as example
    return 'example-based';
  }
}

/**
 * Extract placeholders from markdown template
 */
export function extractPlaceholders(content: string): string[] {
  const regex = /\{\{([^}]+)\}\}/g;
  const matches = [...content.matchAll(regex)];
  const placeholders = matches.map(m => m[1].trim());

  // Deduplicate while preserving order
  return [...new Set(placeholders)];
}

/**
 * Extract sections from markdown template
 * Looks for ## or ### headers with content
 */
export function extractMarkdownSections(content: string): TemplateSection[] {
  const sections: TemplateSection[] = [];
  const lines = content.split('\n');

  let currentSection: Partial<TemplateSection> | null = null;
  let currentContent: string[] = [];
  let sectionIndex = 0;

  for (const line of lines) {
    const headerMatch = line.match(/^(#{2,3})\s+(.+)/);

    if (headerMatch) {
      // Save previous section
      if (currentSection) {
        currentSection.description = currentContent.join('\n').trim();
        sections.push(currentSection as TemplateSection);
      }

      // Start new section
      const name = headerMatch[2].trim();
      currentSection = {
        id: `section-${sectionIndex++}`,
        name,
        description: '',
        required: !name.toLowerCase().includes('optional'),
        placeholder: extractPlaceholders(name)[0] || name
      };
      currentContent = [];
    } else if (currentSection) {
      currentContent.push(line);
    }
  }

  // Don't forget last section
  if (currentSection) {
    currentSection.description = currentContent.join('\n').trim();
    sections.push(currentSection as TemplateSection);
  }

  return sections;
}

/**
 * Extract sections from JSON Schema
 */
export function extractJsonSchemaSections(schema: Record<string, unknown>): TemplateSection[] {
  const sections: TemplateSection[] = [];
  const properties = (schema.properties || {}) as Record<string, unknown>;
  const required = (schema.required || []) as string[];

  for (const [key, value] of Object.entries(properties)) {
    const prop = value as Record<string, unknown>;
    sections.push({
      id: key,
      name: (prop.title as string) || key,
      description: (prop.description as string) || '',
      required: required.includes(key),
      minLength: prop.minLength as number | undefined,
      maxLength: prop.maxLength as number | undefined,
      defaultValue: prop.default as string | undefined
    });
  }

  return sections;
}

/**
 * Parse template into structured format
 */
export class TemplateParser {
  /**
   * Parse template content into structured format
   */
  parse(content: string, name: string = 'Untitled Template'): ParsedTemplate {
    const format = detectTemplateFormat(content);

    let sections: TemplateSection[] = [];
    let placeholders: string[] = [];
    let description: string | undefined;

    switch (format) {
      case 'markdown':
        sections = extractMarkdownSections(content);
        placeholders = extractPlaceholders(content);
        break;

      case 'json-schema':
        try {
          const schema = JSON.parse(content);
          sections = extractJsonSchemaSections(schema);
          placeholders = sections.map(s => s.id);
          description = schema.description;
        } catch {
          sections = [];
          placeholders = [];
        }
        break;

      case 'example-based':
        // For example-based, we extract structure from the example
        try {
          const example = JSON.parse(content);
          const exampleContent = example.example || example.sample || example;
          sections = this.inferSectionsFromExample(exampleContent);
          placeholders = sections.map(s => s.id);
          description = example.description;
        } catch {
          // Plain text example - minimal structure
          sections = [{
            id: 'content',
            name: 'Content',
            description: 'Main content based on example',
            required: true
          }];
          placeholders = ['content'];
        }
        break;
    }

    return {
      format,
      name,
      description,
      sections,
      placeholders,
      rawContent: content
    };
  }

  /**
   * Infer sections from an example document
   */
  private inferSectionsFromExample(example: unknown): TemplateSection[] {
    if (typeof example !== 'object' || example === null) {
      return [];
    }

    const sections: TemplateSection[] = [];
    const obj = example as Record<string, unknown>;

    for (const [key, value] of Object.entries(obj)) {
      const valueStr = typeof value === 'string' ? value : JSON.stringify(value);
      sections.push({
        id: key,
        name: this.formatSectionName(key),
        description: `Section for ${key}. Example: ${valueStr.substring(0, 100)}...`,
        required: true,
        minLength: typeof value === 'string' ? Math.floor(value.length * 0.5) : undefined
      });
    }

    return sections;
  }

  /**
   * Convert camelCase or snake_case to Title Case
   */
  private formatSectionName(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/_/g, ' ')
      .replace(/^\s/, '')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }
}
```

Create src/services/templates/TemplateEngine.ts:

```typescript
import Handlebars from 'handlebars';
import { ParsedTemplate, TemplateSection } from '../../domain/template-types';
import { TemplateParser } from './TemplateParser';

/**
 * Handlebars-based template engine for PRD and task templates
 */
export class TemplateEngine {
  private parser: TemplateParser;
  private compiledCache: Map<string, HandlebarsTemplateDelegate<unknown>>;

  constructor() {
    this.parser = new TemplateParser();
    this.compiledCache = new Map();
    this.registerHelpers();
  }

  /**
   * Register custom Handlebars helpers
   */
  private registerHelpers(): void {
    // Safe iteration helper
    Handlebars.registerHelper('each_safe', function(
      this: unknown,
      context: unknown[],
      options: Handlebars.HelperOptions
    ) {
      if (!context || !Array.isArray(context)) {
        return '';
      }
      return context.map((item, index) =>
        options.fn({ ...item, '@index': index, '@first': index === 0, '@last': index === context.length - 1 })
      ).join('');
    });

    // Conditional with default
    Handlebars.registerHelper('default', function(value: unknown, defaultValue: unknown) {
      return value !== undefined && value !== null && value !== '' ? value : defaultValue;
    });

    // Format as list
    Handlebars.registerHelper('list', function(items: string[]) {
      if (!items || !Array.isArray(items)) return '';
      return items.map(item => `- ${item}`).join('\n');
    });

    // Format as numbered list
    Handlebars.registerHelper('numbered_list', function(items: string[]) {
      if (!items || !Array.isArray(items)) return '';
      return items.map((item, i) => `${i + 1}. ${item}`).join('\n');
    });

    // Join array with separator
    Handlebars.registerHelper('join', function(items: string[], separator: string) {
      if (!items || !Array.isArray(items)) return '';
      return items.join(typeof separator === 'string' ? separator : ', ');
    });

    // Conditional section - only render if value exists and is non-empty
    Handlebars.registerHelper('section_if', function(
      this: unknown,
      condition: unknown,
      options: Handlebars.HelperOptions
    ) {
      const isEmpty = condition === undefined ||
        condition === null ||
        condition === '' ||
        (Array.isArray(condition) && condition.length === 0);

      return isEmpty ? '' : options.fn(this);
    });
  }

  /**
   * Parse template content
   */
  parse(content: string, name?: string): ParsedTemplate {
    return this.parser.parse(content, name);
  }

  /**
   * Compile template for repeated use
   */
  compile(template: string | ParsedTemplate): HandlebarsTemplateDelegate<unknown> {
    const content = typeof template === 'string' ? template : template.rawContent;
    const cacheKey = content.substring(0, 200);

    if (this.compiledCache.has(cacheKey)) {
      return this.compiledCache.get(cacheKey)!;
    }

    try {
      const compiled = Handlebars.compile(content);
      this.compiledCache.set(cacheKey, compiled);
      return compiled;
    } catch (error) {
      throw new Error(`Template compilation failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Render template with data
   */
  render(template: string | ParsedTemplate, data: Record<string, unknown>): string {
    const compiled = this.compile(template);
    try {
      return compiled(data);
    } catch (error) {
      throw new Error(`Template rendering failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Pre-validate template syntax without rendering
   */
  validateSyntax(template: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    try {
      Handlebars.precompile(template);
    } catch (error) {
      errors.push(`Syntax error: ${error instanceof Error ? error.message : String(error)}`);
    }

    // Check for unclosed tags
    const openTags = (template.match(/\{\{#/g) || []).length;
    const closeTags = (template.match(/\{\{\//g) || []).length;
    if (openTags !== closeTags) {
      errors.push(`Mismatched block tags: ${openTags} opening, ${closeTags} closing`);
    }

    // Check for empty placeholders
    if (/\{\{\s*\}\}/.test(template)) {
      errors.push('Empty placeholder found: {{}}');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Get required placeholders that have no default value
   */
  getRequiredPlaceholders(template: ParsedTemplate): string[] {
    return template.sections
      .filter(s => s.required && !s.defaultValue)
      .map(s => s.id);
  }

  /**
   * Create a preview with sample data
   */
  preview(template: string | ParsedTemplate, partialData?: Record<string, unknown>): string {
    const parsed = typeof template === 'string' ? this.parse(template) : template;

    // Generate sample data for missing placeholders
    const sampleData: Record<string, unknown> = { ...partialData };

    for (const placeholder of parsed.placeholders) {
      if (sampleData[placeholder] === undefined) {
        sampleData[placeholder] = `[${placeholder}]`;
      }
    }

    return this.render(parsed, sampleData);
  }

  /**
   * Clear compiled template cache
   */
  clearCache(): void {
    this.compiledCache.clear();
  }
}
```
  </action>
  <verify>
Run: `npm install handlebars && npx tsc --noEmit`
Verify no TypeScript errors and Handlebars is installed
  </verify>
  <done>
Handlebars installed in package.json.
TemplateParser can detect and parse markdown, json-schema, and example-based templates.
TemplateEngine wraps Handlebars with custom helpers and caching.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create template validator</name>
  <files>src/services/templates/TemplateValidator.ts</files>
  <action>
Create src/services/templates/TemplateValidator.ts:

```typescript
import { ParsedTemplate, TemplateValidationResult, TemplateSection } from '../../domain/template-types';
import { TemplateParser, extractPlaceholders } from './TemplateParser';
import { TemplateEngine } from './TemplateEngine';

/**
 * Recommended sections for PRD templates
 */
const RECOMMENDED_PRD_SECTIONS = [
  'overview',
  'objectives',
  'features',
  'scope',
  'timeline',
  'users',
  'requirements',
  'success'
];

/**
 * Recommended sections for task templates
 */
const RECOMMENDED_TASK_SECTIONS = [
  'title',
  'description',
  'acceptance',
  'dependencies',
  'effort',
  'priority'
];

/**
 * Template validator with syntax, coverage, and best practice checks
 */
export class TemplateValidator {
  private parser: TemplateParser;
  private engine: TemplateEngine;

  constructor() {
    this.parser = new TemplateParser();
    this.engine = new TemplateEngine();
  }

  /**
   * Validate template syntax
   */
  validateSyntax(templateContent: string): {
    valid: boolean;
    errors: string[];
  } {
    return this.engine.validateSyntax(templateContent);
  }

  /**
   * Validate template coverage against recommended sections
   */
  validateCoverage(
    template: ParsedTemplate,
    templateType: 'prd' | 'task' = 'prd'
  ): {
    covered: string[];
    missing: string[];
    extra: string[];
    coveragePercent: number;
  } {
    const recommended = templateType === 'prd'
      ? RECOMMENDED_PRD_SECTIONS
      : RECOMMENDED_TASK_SECTIONS;

    const templateSectionNames = template.sections.map(s =>
      s.name.toLowerCase().replace(/[^a-z]/g, '')
    );

    // Also check placeholders
    const templatePlaceholders = template.placeholders.map(p =>
      p.toLowerCase().replace(/[^a-z]/g, '')
    );

    const allTemplateTerms = [...templateSectionNames, ...templatePlaceholders];

    const covered: string[] = [];
    const missing: string[] = [];

    for (const rec of recommended) {
      const found = allTemplateTerms.some(term =>
        term.includes(rec) || rec.includes(term)
      );

      if (found) {
        covered.push(rec);
      } else {
        missing.push(rec);
      }
    }

    // Find sections that aren't in recommended (not necessarily bad)
    const extra = template.sections
      .map(s => s.name)
      .filter(name => {
        const normalized = name.toLowerCase().replace(/[^a-z]/g, '');
        return !recommended.some(rec =>
          normalized.includes(rec) || rec.includes(normalized)
        );
      });

    const coveragePercent = Math.round((covered.length / recommended.length) * 100);

    return { covered, missing, extra, coveragePercent };
  }

  /**
   * Validate section requirements
   */
  validateSectionRequirements(sections: TemplateSection[]): {
    valid: boolean;
    issues: Array<{ section: string; issue: string; severity: 'error' | 'warning' }>;
  } {
    const issues: Array<{ section: string; issue: string; severity: 'error' | 'warning' }> = [];

    for (const section of sections) {
      // Check for empty names
      if (!section.name || section.name.trim().length === 0) {
        issues.push({
          section: section.id,
          issue: 'Section has no name',
          severity: 'error'
        });
      }

      // Check for very long min lengths
      if (section.minLength && section.minLength > 10000) {
        issues.push({
          section: section.name,
          issue: 'Minimum length is excessively high (>10000)',
          severity: 'warning'
        });
      }

      // Check for max < min
      if (section.minLength && section.maxLength && section.maxLength < section.minLength) {
        issues.push({
          section: section.name,
          issue: 'Maximum length is less than minimum length',
          severity: 'error'
        });
      }
    }

    return {
      valid: issues.filter(i => i.severity === 'error').length === 0,
      issues
    };
  }

  /**
   * Full template validation
   */
  validate(
    templateContent: string,
    templateType: 'prd' | 'task' = 'prd',
    templateName?: string
  ): TemplateValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // 1. Syntax validation
    const syntaxResult = this.validateSyntax(templateContent);
    if (!syntaxResult.valid) {
      errors.push(...syntaxResult.errors);
    }

    // 2. Parse template
    let template: ParsedTemplate;
    try {
      template = this.parser.parse(templateContent, templateName);
    } catch (e) {
      errors.push(`Parse error: ${e instanceof Error ? e.message : String(e)}`);
      return {
        valid: false,
        errors,
        warnings,
        placeholders: [],
        missingSections: []
      };
    }

    // 3. Coverage validation
    const coverage = this.validateCoverage(template, templateType);
    if (coverage.missing.length > 0) {
      warnings.push(
        `Missing recommended sections: ${coverage.missing.join(', ')}. ` +
        `Coverage: ${coverage.coveragePercent}%`
      );
    }

    // 4. Section requirements validation
    const sectionValidation = this.validateSectionRequirements(template.sections);
    for (const issue of sectionValidation.issues) {
      if (issue.severity === 'error') {
        errors.push(`${issue.section}: ${issue.issue}`);
      } else {
        warnings.push(`${issue.section}: ${issue.issue}`);
      }
    }

    // 5. Placeholder validation
    const placeholders = extractPlaceholders(templateContent);

    // Check for duplicate placeholders with different casings
    const normalizedPlaceholders = new Map<string, string[]>();
    for (const p of placeholders) {
      const normalized = p.toLowerCase();
      if (!normalizedPlaceholders.has(normalized)) {
        normalizedPlaceholders.set(normalized, []);
      }
      normalizedPlaceholders.get(normalized)!.push(p);
    }

    for (const [normalized, variants] of normalizedPlaceholders) {
      if (variants.length > 1) {
        warnings.push(
          `Placeholder '${normalized}' has multiple casings: ${variants.join(', ')}. ` +
          'This may cause confusion.'
        );
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      placeholders,
      missingSections: coverage.missing
    };
  }

  /**
   * Generate sample data for template preview
   */
  generateSampleData(template: ParsedTemplate): Record<string, unknown> {
    const sampleData: Record<string, unknown> = {};

    for (const section of template.sections) {
      if (section.defaultValue) {
        sampleData[section.id] = section.defaultValue;
      } else {
        // Generate placeholder content based on section type
        const name = section.name.toLowerCase();

        if (name.includes('list') || name.includes('features') || name.includes('objectives')) {
          sampleData[section.id] = ['Example item 1', 'Example item 2', 'Example item 3'];
        } else if (name.includes('date') || name.includes('timeline')) {
          sampleData[section.id] = new Date().toISOString().split('T')[0];
        } else if (name.includes('number') || name.includes('count') || name.includes('effort')) {
          sampleData[section.id] = 5;
        } else {
          sampleData[section.id] = `Sample ${section.name} content`;
        }
      }
    }

    return sampleData;
  }
}
```
  </action>
  <verify>
Run: `npx tsc --noEmit`
Verify TemplateValidator compiles with all validation methods
  </verify>
  <done>
TemplateValidator exists with validateSyntax, validateCoverage, validateSectionRequirements, and full validate methods.
Recommended sections defined for PRD and task templates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PRD validation rule engine</name>
  <files>
    src/infrastructure/validation/ValidationRuleEngine.ts
    src/infrastructure/validation/PRDValidator.ts
    src/infrastructure/validation/rules/CompletenessRules.ts
    src/infrastructure/validation/rules/ClarityRules.ts
  </files>
  <action>
Create directory structure:
```bash
mkdir -p src/infrastructure/validation/rules
```

Create src/infrastructure/validation/ValidationRuleEngine.ts:

```typescript
import { PRDDocument } from '../../domain/ai-types';

/**
 * Validation rule severity levels
 */
export type ValidationSeverity = 'critical' | 'major' | 'minor';

/**
 * Validation rule categories
 */
export type ValidationCategory = 'completeness' | 'clarity' | 'feasibility' | 'testability' | 'consistency';

/**
 * Validation rule layers
 */
export type ValidationLayer = 'builtin' | 'standard' | 'custom';

/**
 * Result of a single validation check
 */
export interface ValidationCheckResult {
  passed: boolean;
  message: string;
  location?: string;           // Where in the document the issue is
  suggestedFix?: string;       // How to fix the issue
  diff?: {
    before: string;
    after: string;
  };
  affectedSection?: string;
}

/**
 * Validation rule interface
 */
export interface ValidationRule {
  id: string;
  name: string;
  description: string;
  layer: ValidationLayer;
  severity: ValidationSeverity;
  category: ValidationCategory;
  enabled: boolean;
  check: (prd: PRDDocument) => ValidationCheckResult;
  autoFix?: (prd: PRDDocument) => PRDDocument;
}

/**
 * Aggregated validation results
 */
export interface ValidationResults {
  valid: boolean;
  score: number;               // 0-100 quality score
  totalRules: number;
  passedRules: number;
  failedRules: number;
  results: Array<{
    rule: Pick<ValidationRule, 'id' | 'name' | 'severity' | 'category'>;
    result: ValidationCheckResult;
  }>;
  criticalIssues: number;
  majorIssues: number;
  minorIssues: number;
}

/**
 * Validation rule engine with layered rule support
 */
export class ValidationRuleEngine {
  private rules: Map<string, ValidationRule> = new Map();
  private enabledLayers: Set<ValidationLayer> = new Set(['builtin']);

  constructor() {
    // Built-in rules are always enabled by default
    this.enabledLayers.add('builtin');
  }

  /**
   * Register a validation rule
   */
  registerRule(rule: ValidationRule): void {
    this.rules.set(rule.id, rule);
  }

  /**
   * Register multiple rules
   */
  registerRules(rules: ValidationRule[]): void {
    for (const rule of rules) {
      this.registerRule(rule);
    }
  }

  /**
   * Enable a validation layer
   */
  enableLayer(layer: ValidationLayer): void {
    this.enabledLayers.add(layer);
  }

  /**
   * Disable a validation layer
   */
  disableLayer(layer: ValidationLayer): void {
    // Can't disable builtin
    if (layer !== 'builtin') {
      this.enabledLayers.delete(layer);
    }
  }

  /**
   * Enable/disable a specific rule
   */
  setRuleEnabled(ruleId: string, enabled: boolean): void {
    const rule = this.rules.get(ruleId);
    if (rule) {
      rule.enabled = enabled;
    }
  }

  /**
   * Get all registered rules
   */
  getRules(): ValidationRule[] {
    return Array.from(this.rules.values());
  }

  /**
   * Get rules by category
   */
  getRulesByCategory(category: ValidationCategory): ValidationRule[] {
    return this.getRules().filter(r => r.category === category);
  }

  /**
   * Run all enabled rules against a PRD
   */
  validate(prd: PRDDocument): ValidationResults {
    const results: ValidationResults['results'] = [];
    let passedRules = 0;
    let failedRules = 0;
    let criticalIssues = 0;
    let majorIssues = 0;
    let minorIssues = 0;

    for (const rule of this.rules.values()) {
      // Skip disabled rules or rules from disabled layers
      if (!rule.enabled || !this.enabledLayers.has(rule.layer)) {
        continue;
      }

      try {
        const checkResult = rule.check(prd);

        results.push({
          rule: {
            id: rule.id,
            name: rule.name,
            severity: rule.severity,
            category: rule.category
          },
          result: checkResult
        });

        if (checkResult.passed) {
          passedRules++;
        } else {
          failedRules++;

          switch (rule.severity) {
            case 'critical':
              criticalIssues++;
              break;
            case 'major':
              majorIssues++;
              break;
            case 'minor':
              minorIssues++;
              break;
          }
        }
      } catch (error) {
        // Rule execution failed - treat as failed check
        results.push({
          rule: {
            id: rule.id,
            name: rule.name,
            severity: rule.severity,
            category: rule.category
          },
          result: {
            passed: false,
            message: `Rule execution error: ${error instanceof Error ? error.message : String(error)}`
          }
        });
        failedRules++;
        minorIssues++;
      }
    }

    const totalRules = passedRules + failedRules;
    const score = totalRules > 0
      ? Math.round((passedRules / totalRules) * 100 - (criticalIssues * 10) - (majorIssues * 5))
      : 100;

    return {
      valid: criticalIssues === 0,  // Valid if no critical issues
      score: Math.max(0, Math.min(100, score)),
      totalRules,
      passedRules,
      failedRules,
      results,
      criticalIssues,
      majorIssues,
      minorIssues
    };
  }

  /**
   * Auto-fix issues where possible
   */
  autoFix(prd: PRDDocument, ruleIds?: string[]): {
    prd: PRDDocument;
    fixedIssues: string[];
    unfixableIssues: string[];
  } {
    let fixedPrd = { ...prd };
    const fixedIssues: string[] = [];
    const unfixableIssues: string[] = [];

    const rulesToCheck = ruleIds
      ? ruleIds.map(id => this.rules.get(id)).filter((r): r is ValidationRule => r !== undefined)
      : Array.from(this.rules.values());

    for (const rule of rulesToCheck) {
      if (!rule.enabled || !this.enabledLayers.has(rule.layer)) {
        continue;
      }

      const checkResult = rule.check(fixedPrd);

      if (!checkResult.passed) {
        if (rule.autoFix) {
          try {
            fixedPrd = rule.autoFix(fixedPrd);
            fixedIssues.push(rule.id);
          } catch {
            unfixableIssues.push(rule.id);
          }
        } else {
          unfixableIssues.push(rule.id);
        }
      }
    }

    return { prd: fixedPrd, fixedIssues, unfixableIssues };
  }
}
```

Create src/infrastructure/validation/rules/CompletenessRules.ts:

```typescript
import { ValidationRule } from '../ValidationRuleEngine';
import { PRDDocument } from '../../../domain/ai-types';

/**
 * Built-in completeness validation rules
 */
export const COMPLETENESS_RULES: ValidationRule[] = [
  {
    id: 'BR-001',
    name: 'Overview Required',
    description: 'PRD must have an overview of at least 100 characters',
    layer: 'builtin',
    severity: 'critical',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const hasOverview = prd.overview && prd.overview.length >= 100;
      return {
        passed: hasOverview,
        message: hasOverview
          ? 'PRD has adequate overview'
          : `PRD overview is ${prd.overview?.length || 0} characters (minimum 100)`,
        location: 'overview',
        suggestedFix: 'Expand the overview with project goals, context, and value proposition'
      };
    },
    autoFix: undefined // Can't auto-fix - needs human input
  },

  {
    id: 'BR-002',
    name: 'Objectives Defined',
    description: 'PRD must have at least 2 clear objectives',
    layer: 'builtin',
    severity: 'critical',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const objectiveCount = prd.objectives?.length || 0;
      const hasEnough = objectiveCount >= 2;
      return {
        passed: hasEnough,
        message: hasEnough
          ? `PRD has ${objectiveCount} objectives`
          : `PRD has only ${objectiveCount} objectives (minimum 2)`,
        location: 'objectives',
        suggestedFix: 'Add clear, measurable objectives for the project'
      };
    }
  },

  {
    id: 'BR-003',
    name: 'Features Listed',
    description: 'PRD must have at least 1 feature requirement',
    layer: 'builtin',
    severity: 'critical',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const featureCount = prd.features?.length || 0;
      const hasFeatures = featureCount >= 1;
      return {
        passed: hasFeatures,
        message: hasFeatures
          ? `PRD has ${featureCount} features`
          : 'PRD has no features defined',
        location: 'features',
        suggestedFix: 'Add at least one feature with clear acceptance criteria'
      };
    }
  },

  {
    id: 'BR-004',
    name: 'Success Metrics Defined',
    description: 'PRD should have measurable success metrics',
    layer: 'builtin',
    severity: 'major',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const metricsCount = prd.successMetrics?.length || 0;
      const hasMetrics = metricsCount >= 1;
      return {
        passed: hasMetrics,
        message: hasMetrics
          ? `PRD has ${metricsCount} success metrics`
          : 'PRD has no success metrics',
        location: 'successMetrics',
        suggestedFix: 'Add measurable success criteria (e.g., "95% uptime", "< 2s response time")'
      };
    }
  },

  {
    id: 'BR-005',
    name: 'Target Users Identified',
    description: 'PRD should identify target user personas',
    layer: 'builtin',
    severity: 'major',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const userCount = prd.targetUsers?.length || 0;
      const hasUsers = userCount >= 1;
      return {
        passed: hasUsers,
        message: hasUsers
          ? `PRD identifies ${userCount} user persona(s)`
          : 'PRD has no target users defined',
        location: 'targetUsers',
        suggestedFix: 'Add user personas with goals, pain points, and technical level'
      };
    }
  },

  {
    id: 'BR-006',
    name: 'Timeline Specified',
    description: 'PRD should include a timeline or schedule',
    layer: 'builtin',
    severity: 'minor',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const hasTimeline = prd.timeline && prd.timeline.length > 10;
      return {
        passed: hasTimeline,
        message: hasTimeline
          ? 'PRD has timeline specified'
          : 'PRD has no timeline or schedule',
        location: 'timeline',
        suggestedFix: 'Add project timeline with key milestones'
      };
    }
  },

  {
    id: 'BR-007',
    name: 'Scope Boundaries Defined',
    description: 'PRD should clearly define what is in and out of scope',
    layer: 'builtin',
    severity: 'major',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const hasInScope = prd.scope?.inScope && prd.scope.inScope.length > 0;
      const hasOutOfScope = prd.scope?.outOfScope && prd.scope.outOfScope.length > 0;
      const passed = hasInScope && hasOutOfScope;
      return {
        passed,
        message: passed
          ? 'PRD has clear scope boundaries'
          : `PRD scope incomplete: ${!hasInScope ? 'missing in-scope items' : ''} ${!hasOutOfScope ? 'missing out-of-scope items' : ''}`,
        location: 'scope',
        suggestedFix: 'Define both in-scope and out-of-scope items explicitly'
      };
    }
  },

  {
    id: 'BR-008',
    name: 'Technical Requirements Present',
    description: 'PRD should include technical requirements',
    layer: 'builtin',
    severity: 'minor',
    category: 'completeness',
    enabled: true,
    check: (prd: PRDDocument) => {
      const techReqCount = prd.technicalRequirements?.length || 0;
      const hasTechReqs = techReqCount >= 1;
      return {
        passed: hasTechReqs,
        message: hasTechReqs
          ? `PRD has ${techReqCount} technical requirements`
          : 'PRD has no technical requirements',
        location: 'technicalRequirements',
        suggestedFix: 'Add technical requirements for performance, security, scalability'
      };
    }
  }
];
```

Create src/infrastructure/validation/rules/ClarityRules.ts:

```typescript
import { ValidationRule } from '../ValidationRuleEngine';
import { PRDDocument, FeatureRequirement } from '../../../domain/ai-types';

/**
 * Built-in clarity validation rules
 */
export const CLARITY_RULES: ValidationRule[] = [
  {
    id: 'CL-001',
    name: 'Feature Descriptions Clear',
    description: 'Each feature should have a description of at least 50 characters',
    layer: 'builtin',
    severity: 'major',
    category: 'clarity',
    enabled: true,
    check: (prd: PRDDocument) => {
      const features = prd.features || [];
      const shortFeatures = features.filter(f => !f.description || f.description.length < 50);

      if (shortFeatures.length === 0) {
        return {
          passed: true,
          message: 'All feature descriptions are adequate'
        };
      }

      return {
        passed: false,
        message: `${shortFeatures.length} feature(s) have descriptions under 50 characters`,
        location: 'features',
        suggestedFix: `Expand descriptions for: ${shortFeatures.map(f => f.title).join(', ')}`,
        affectedSection: 'features'
      };
    }
  },

  {
    id: 'CL-002',
    name: 'Acceptance Criteria Present',
    description: 'Features should have acceptance criteria',
    layer: 'builtin',
    severity: 'major',
    category: 'clarity',
    enabled: true,
    check: (prd: PRDDocument) => {
      const features = prd.features || [];
      const missingCriteria = features.filter(
        f => !f.acceptanceCriteria || f.acceptanceCriteria.length === 0
      );

      if (missingCriteria.length === 0) {
        return {
          passed: true,
          message: 'All features have acceptance criteria'
        };
      }

      return {
        passed: false,
        message: `${missingCriteria.length} feature(s) missing acceptance criteria`,
        location: 'features',
        suggestedFix: `Add acceptance criteria for: ${missingCriteria.map(f => f.title).join(', ')}`,
        affectedSection: 'features'
      };
    }
  },

  {
    id: 'CL-003',
    name: 'No Vague Language in Objectives',
    description: 'Objectives should not use vague words like "improve", "enhance" without metrics',
    layer: 'builtin',
    severity: 'minor',
    category: 'clarity',
    enabled: true,
    check: (prd: PRDDocument) => {
      const vagueWords = ['improve', 'enhance', 'better', 'good', 'fast', 'easy', 'nice'];
      const objectives = prd.objectives || [];

      const vagueObjectives = objectives.filter(obj => {
        const lower = obj.toLowerCase();
        // Check if vague word exists without an accompanying metric
        const hasVague = vagueWords.some(w => lower.includes(w));
        const hasMetric = /\d+%|\d+x|by \d+|to \d+|under \d+|over \d+/.test(obj);
        return hasVague && !hasMetric;
      });

      if (vagueObjectives.length === 0) {
        return {
          passed: true,
          message: 'Objectives are specific and measurable'
        };
      }

      return {
        passed: false,
        message: `${vagueObjectives.length} objective(s) use vague language without metrics`,
        location: 'objectives',
        suggestedFix: 'Add specific metrics (e.g., "improve performance by 50%")',
        affectedSection: 'objectives'
      };
    }
  },

  {
    id: 'CL-004',
    name: 'User Stories Present',
    description: 'Features should have user stories describing use cases',
    layer: 'builtin',
    severity: 'minor',
    category: 'clarity',
    enabled: true,
    check: (prd: PRDDocument) => {
      const features = prd.features || [];
      const missingStories = features.filter(
        f => !f.userStories || f.userStories.length === 0
      );

      if (missingStories.length === 0) {
        return {
          passed: true,
          message: 'All features have user stories'
        };
      }

      return {
        passed: false,
        message: `${missingStories.length} feature(s) missing user stories`,
        location: 'features',
        suggestedFix: `Add "As a [user], I want to [action] so that [benefit]" stories`,
        affectedSection: 'features'
      };
    }
  },

  {
    id: 'CL-005',
    name: 'Persona Goals Defined',
    description: 'User personas should have defined goals',
    layer: 'builtin',
    severity: 'minor',
    category: 'clarity',
    enabled: true,
    check: (prd: PRDDocument) => {
      const users = prd.targetUsers || [];
      const missingGoals = users.filter(u => !u.goals || u.goals.length === 0);

      if (missingGoals.length === 0) {
        return {
          passed: true,
          message: 'All user personas have defined goals'
        };
      }

      return {
        passed: false,
        message: `${missingGoals.length} persona(s) missing goals`,
        location: 'targetUsers',
        suggestedFix: `Add goals for: ${missingGoals.map(u => u.name).join(', ')}`,
        affectedSection: 'targetUsers'
      };
    }
  }
];
```

Create src/infrastructure/validation/PRDValidator.ts:

```typescript
import { PRDDocument } from '../../domain/ai-types';
import { ValidationRuleEngine, ValidationResults, ValidationRule } from './ValidationRuleEngine';
import { COMPLETENESS_RULES } from './rules/CompletenessRules';
import { CLARITY_RULES } from './rules/ClarityRules';

/**
 * PRD-specific validator with built-in rules
 */
export class PRDValidator {
  private ruleEngine: ValidationRuleEngine;

  constructor() {
    this.ruleEngine = new ValidationRuleEngine();

    // Register all built-in rules
    this.ruleEngine.registerRules(COMPLETENESS_RULES);
    this.ruleEngine.registerRules(CLARITY_RULES);
  }

  /**
   * Validate a PRD document
   */
  validate(prd: PRDDocument): ValidationResults {
    return this.ruleEngine.validate(prd);
  }

  /**
   * Get validation summary for display
   */
  getValidationSummary(results: ValidationResults): string {
    const lines: string[] = [];

    lines.push(`PRD Validation Score: ${results.score}/100`);
    lines.push(`Status: ${results.valid ? 'VALID' : 'INVALID'}`);
    lines.push('');
    lines.push(`Rules: ${results.passedRules}/${results.totalRules} passed`);

    if (results.criticalIssues > 0) {
      lines.push(`Critical Issues: ${results.criticalIssues}`);
    }
    if (results.majorIssues > 0) {
      lines.push(`Major Issues: ${results.majorIssues}`);
    }
    if (results.minorIssues > 0) {
      lines.push(`Minor Issues: ${results.minorIssues}`);
    }

    lines.push('');
    lines.push('Issues:');

    const failedResults = results.results.filter(r => !r.result.passed);
    for (const { rule, result } of failedResults) {
      lines.push(`  [${rule.severity.toUpperCase()}] ${rule.name}`);
      lines.push(`    ${result.message}`);
      if (result.suggestedFix) {
        lines.push(`    Fix: ${result.suggestedFix}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Add custom validation rule
   */
  addRule(rule: ValidationRule): void {
    this.ruleEngine.registerRule(rule);
  }

  /**
   * Enable standard rules (optional industry standards)
   */
  enableStandardRules(): void {
    this.ruleEngine.enableLayer('standard');
  }

  /**
   * Enable custom rules
   */
  enableCustomRules(): void {
    this.ruleEngine.enableLayer('custom');
  }

  /**
   * Auto-fix issues where possible
   */
  autoFix(prd: PRDDocument): {
    prd: PRDDocument;
    fixedIssues: string[];
    unfixableIssues: string[];
  } {
    return this.ruleEngine.autoFix(prd);
  }

  /**
   * Get all registered rules
   */
  getRules(): ValidationRule[] {
    return this.ruleEngine.getRules();
  }
}
```
  </action>
  <verify>
Run: `npx tsc --noEmit`
Verify all validation files compile without errors
  </verify>
  <done>
ValidationRuleEngine exists with layered rule support (builtin, standard, custom).
CompletenessRules has 8 rules checking overview, objectives, features, metrics, users, timeline, scope.
ClarityRules has 5 rules checking descriptions, acceptance criteria, vague language, user stories.
PRDValidator aggregates rules and provides validation summary with auto-fix capability.
  </done>
</task>

</tasks>

<verification>
1. Run `npm install handlebars && npx tsc --noEmit` - no errors
2. Verify Handlebars in package.json dependencies
3. Verify src/services/templates/ directory has TemplateEngine.ts, TemplateParser.ts, TemplateValidator.ts
4. Verify src/infrastructure/validation/ has PRDValidator.ts, ValidationRuleEngine.ts
5. Verify src/infrastructure/validation/rules/ has CompletenessRules.ts, ClarityRules.ts
</verification>

<success_criteria>
- Handlebars installed as dependency
- TemplateParser.detectTemplateFormat correctly identifies markdown, json-schema, example-based
- TemplateEngine.render produces output with placeholder substitution
- TemplateValidator.validate returns errors and warnings
- PRDValidator.validate returns score and categorized issues
- 13 built-in validation rules registered (8 completeness + 5 clarity)
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-prd-task-enhancement/09-02-SUMMARY.md`
</output>
