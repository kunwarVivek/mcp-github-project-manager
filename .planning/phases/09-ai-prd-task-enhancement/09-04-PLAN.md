---
phase: 09-ai-prd-task-enhancement
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - src/services/TaskGenerationService.ts
  - tests/ai-services/ConfidenceScorer.test.ts
  - tests/ai-services/DependencyGraph.test.ts
  - tests/ai-services/EstimationCalibrator.test.ts
  - tests/ai-services/TemplateEngine.test.ts
  - tests/ai-services/PRDValidator.test.ts
  - docs/TOOLS.md
  - .planning/STATUS.md
autonomous: true

must_haves:
  truths:
    - "Task generation includes effort estimates and dependency analysis"
    - "All new services have unit tests with 80%+ coverage"
    - "Documentation updated with AI enhancement features"
  artifacts:
    - path: "src/services/TaskGenerationService.ts"
      provides: "Enhanced task generation with effort and dependencies"
      contains: "effortEstimate"
    - path: "tests/ai-services/ConfidenceScorer.test.ts"
      provides: "Unit tests for confidence scoring"
      min_lines: 100
    - path: "tests/ai-services/DependencyGraph.test.ts"
      provides: "Unit tests for dependency analysis"
      min_lines: 100
    - path: "tests/ai-services/EstimationCalibrator.test.ts"
      provides: "Unit tests for estimation calibration"
      min_lines: 80
  key_links:
    - from: "src/services/TaskGenerationService.ts"
      to: "src/analysis/DependencyGraph.ts"
      via: "dependency detection integration"
      pattern: "DependencyGraph"
    - from: "src/services/TaskGenerationService.ts"
      to: "src/analysis/EstimationCalibrator.ts"
      via: "effort estimation integration"
      pattern: "EstimationCalibrator"
---

<objective>
Complete task generation enhancements with effort estimation, dependency detection, and comprehensive tests.

Purpose: Finalize Phase 9 by integrating effort estimation and dependency detection into task generation, adding unit tests for all new services, and updating documentation.

Output: Enhanced TaskGenerationService, comprehensive test suite (120+ tests), updated TOOLS.md and STATUS.md.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-prd-task-enhancement/09-02-SUMMARY.md
@.planning/phases/09-ai-prd-task-enhancement/09-03-SUMMARY.md
@src/services/TaskGenerationService.ts
@src/analysis/DependencyGraph.ts
@src/analysis/EstimationCalibrator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance TaskGenerationService with effort and dependency analysis</name>
  <files>src/services/TaskGenerationService.ts</files>
  <action>
Add imports at top of src/services/TaskGenerationService.ts:

```typescript
import { DependencyGraph, DetectedDependency, GraphAnalysisResult } from '../analysis/DependencyGraph';
import { EstimationCalibrator, EffortEstimate } from '../analysis/EstimationCalibrator';
import { ConfidenceScorer, calculateInputCompleteness } from './ai/ConfidenceScorer';
import { SectionConfidence, ConfidenceConfig, DEFAULT_CONFIDENCE_CONFIG } from '../domain/ai-types';
```

Add new properties to TaskGenerationService class:

```typescript
private dependencyGraph: DependencyGraph;
private estimationCalibrator: EstimationCalibrator;
private confidenceScorer: ConfidenceScorer;

constructor() {
  this.aiProcessor = new AITaskProcessor();
  this.traceabilityService = new RequirementsTraceabilityService();
  this.contextGenerationService = new TaskContextGenerationService();
  this.dependencyGraph = new DependencyGraph();
  this.estimationCalibrator = new EstimationCalibrator();
  this.confidenceScorer = new ConfidenceScorer();
}
```

Add new types after imports:

```typescript
/**
 * Task with effort estimate and dependency analysis
 */
export interface EnhancedTaskWithEstimate extends EnhancedAITask {
  effortEstimate: EffortEstimate;
  detectedDependencies: DetectedDependency[];
  taskConfidence: SectionConfidence;
}

/**
 * Task generation result with analysis
 */
export interface TaskGenerationResult {
  tasks: EnhancedTaskWithEstimate[];
  graphAnalysis: GraphAnalysisResult;
  overallConfidence: { score: number; tier: 'high' | 'medium' | 'low' };
  lowConfidenceTasks: EnhancedTaskWithEstimate[];
  estimationStats: {
    totalPoints: number;
    averageConfidence: number;
    calibrated: boolean;
  };
}
```

Add new method to TaskGenerationService class:

```typescript
/**
 * Generate tasks with effort estimation and dependency analysis
 */
async generateTasksWithAnalysis(params: {
  prd: PRDDocument | string;
  projectId?: string;
  maxTasks?: number;
  businessObjectives?: string[];
  confidenceConfig?: Partial<ConfidenceConfig>;
}): Promise<TaskGenerationResult> {
  const config = { ...DEFAULT_CONFIDENCE_CONFIG, ...params.confidenceConfig };

  // Generate enhanced tasks using existing method
  const enhancedTasks = await this.generateEnhancedTasksFromPRD({
    prd: params.prd,
    projectId: params.projectId,
    maxTasks: params.maxTasks || MAX_TASKS_PER_PRD,
    businessObjectives: params.businessObjectives
  });

  // Reset graph for new analysis
  this.dependencyGraph = new DependencyGraph();

  // Process each task with effort estimation and confidence
  const tasksWithEstimates: EnhancedTaskWithEstimate[] = [];

  for (const task of enhancedTasks) {
    // Add to dependency graph
    this.dependencyGraph.addTask(task);

    // Generate effort estimate
    const effortEstimate = this.estimationCalibrator.estimate({
      complexity: task.complexity,
      title: task.title,
      description: task.description,
      tags: task.tags
    });

    // Record for future calibration
    this.estimationCalibrator.recordEstimate({
      taskId: task.id,
      title: task.title,
      estimatedPoints: effortEstimate.points,
      complexity: task.complexity,
      tags: task.tags
    });

    // Calculate task confidence
    const prdContent = typeof params.prd === 'string'
      ? params.prd
      : JSON.stringify(params.prd);

    const taskConfidence = this.confidenceScorer.calculateSectionConfidence({
      sectionId: task.id,
      sectionName: task.title,
      inputData: {
        description: task.description,
        context: prdContent.substring(0, 500),
        requirements: task.acceptanceCriteria.map(ac => ac.description)
      },
      aiSelfAssessment: 0.7, // Default - could be enhanced with AI assessment
      patternMatchScore: this.calculateTaskPatternMatch(task)
    });

    tasksWithEstimates.push({
      ...task,
      effortEstimate,
      detectedDependencies: [],
      taskConfidence
    });
  }

  // Detect implicit dependencies
  const implicitDeps = this.dependencyGraph.detectImplicitDependencies(0.5);

  // Assign detected dependencies to tasks
  for (const task of tasksWithEstimates) {
    task.detectedDependencies = implicitDeps.filter(d => d.toTaskId === task.id);
  }

  // Run graph analysis
  const graphAnalysis = this.dependencyGraph.analyze();

  // Calculate overall confidence
  const confidenceScores = tasksWithEstimates.map(t => t.taskConfidence);
  const aggregated = this.confidenceScorer.aggregateConfidence(confidenceScores);

  // Find low confidence tasks
  const lowConfidenceTasks = tasksWithEstimates.filter(
    t => t.taskConfidence.tier === 'low'
  );

  // Calculate estimation stats
  const totalPoints = tasksWithEstimates.reduce(
    (sum, t) => sum + t.effortEstimate.points,
    0
  );
  const averageConfidence = Math.round(
    tasksWithEstimates.reduce((sum, t) => sum + t.effortEstimate.confidence, 0) /
    tasksWithEstimates.length
  );
  const calibrated = tasksWithEstimates.some(t => t.effortEstimate.calibrated);

  return {
    tasks: tasksWithEstimates,
    graphAnalysis,
    overallConfidence: {
      score: aggregated.overallScore,
      tier: aggregated.overallTier
    },
    lowConfidenceTasks,
    estimationStats: {
      totalPoints,
      averageConfidence,
      calibrated
    }
  };
}

/**
 * Calculate pattern match score for a task based on common patterns
 */
private calculateTaskPatternMatch(task: AITask): number {
  let score = 0.5;

  // Tasks with clear acceptance criteria score higher
  if (task.acceptanceCriteria.length >= 3) score += 0.15;
  else if (task.acceptanceCriteria.length >= 1) score += 0.08;

  // Tasks with explicit dependencies score higher
  if (task.dependencies.length > 0) score += 0.1;

  // Tasks with reasonable description length
  if (task.description.length >= 100) score += 0.1;
  else if (task.description.length >= 50) score += 0.05;

  // Tasks with tags for categorization
  if (task.tags.length > 0) score += 0.05;

  return Math.min(1, score);
}

/**
 * Record actual effort for a completed task (for calibration)
 */
recordActualEffort(taskId: string, actualPoints: number): boolean {
  return this.estimationCalibrator.recordActual(taskId, actualPoints);
}

/**
 * Get estimation accuracy statistics
 */
getEstimationStats(): ReturnType<typeof EstimationCalibrator.prototype.getAccuracyStats> {
  return this.estimationCalibrator.getAccuracyStats();
}

/**
 * Export estimation records for persistence
 */
exportEstimationRecords(): ReturnType<typeof EstimationCalibrator.prototype.exportRecords> {
  return this.estimationCalibrator.exportRecords();
}

/**
 * Import estimation records from persistence
 */
importEstimationRecords(records: Parameters<typeof EstimationCalibrator.prototype.importRecords>[0]): void {
  this.estimationCalibrator.importRecords(records);
}
```
  </action>
  <verify>
Run: `npx tsc --noEmit`
Verify TaskGenerationService compiles with new methods
  </verify>
  <done>
TaskGenerationService has generateTasksWithAnalysis method returning TaskGenerationResult.
Effort estimation integrated via EstimationCalibrator.
Dependency detection integrated via DependencyGraph.
recordActualEffort method enables calibration feedback loop.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for new services</name>
  <files>
    tests/ai-services/ConfidenceScorer.test.ts
    tests/ai-services/DependencyGraph.test.ts
    tests/ai-services/EstimationCalibrator.test.ts
    tests/ai-services/TemplateEngine.test.ts
    tests/ai-services/PRDValidator.test.ts
  </files>
  <action>
Create tests/ai-services/ConfidenceScorer.test.ts:

```typescript
import {
  ConfidenceScorer,
  calculateInputCompleteness,
  getConfidenceTier,
  calculateWeightedScore,
  generateClarifyingQuestions
} from '../../src/services/ai/ConfidenceScorer';
import { DEFAULT_CONFIDENCE_CONFIG } from '../../src/domain/ai-types';

describe('ConfidenceScorer', () => {
  describe('calculateInputCompleteness', () => {
    it('returns 0 for empty input', () => {
      const score = calculateInputCompleteness({});
      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(1);
    });

    it('returns higher score for complete input', () => {
      const emptyScore = calculateInputCompleteness({});
      const completeScore = calculateInputCompleteness({
        description: 'A detailed description of over 500 characters. '.repeat(20),
        examples: ['Example 1', 'Example 2', 'Example 3'],
        constraints: ['Constraint 1', 'Constraint 2'],
        context: 'Additional context information that is quite lengthy',
        requirements: ['Req 1', 'Req 2', 'Req 3']
      });

      expect(completeScore).toBeGreaterThan(emptyScore);
      expect(completeScore).toBeGreaterThan(0.5);
    });

    it('increases score with description length', () => {
      const shortScore = calculateInputCompleteness({
        description: 'Short'
      });
      const longScore = calculateInputCompleteness({
        description: 'A much longer description that provides more context and details about the project requirements and goals'.repeat(5)
      });

      expect(longScore).toBeGreaterThan(shortScore);
    });

    it('increases score with examples', () => {
      const noExamples = calculateInputCompleteness({
        description: 'Test'
      });
      const withExamples = calculateInputCompleteness({
        description: 'Test',
        examples: ['Ex1', 'Ex2', 'Ex3', 'Ex4']
      });

      expect(withExamples).toBeGreaterThan(noExamples);
    });
  });

  describe('getConfidenceTier', () => {
    it('returns high for scores >= 70', () => {
      expect(getConfidenceTier(70)).toBe('high');
      expect(getConfidenceTier(85)).toBe('high');
      expect(getConfidenceTier(100)).toBe('high');
    });

    it('returns medium for scores 50-69', () => {
      expect(getConfidenceTier(50)).toBe('medium');
      expect(getConfidenceTier(60)).toBe('medium');
      expect(getConfidenceTier(69)).toBe('medium');
    });

    it('returns low for scores < 50', () => {
      expect(getConfidenceTier(0)).toBe('low');
      expect(getConfidenceTier(25)).toBe('low');
      expect(getConfidenceTier(49)).toBe('low');
    });

    it('respects custom thresholds', () => {
      const customConfig = {
        ...DEFAULT_CONFIDENCE_CONFIG,
        warningThreshold: 80,
        errorThreshold: 60
      };

      expect(getConfidenceTier(75, customConfig)).toBe('medium');
      expect(getConfidenceTier(55, customConfig)).toBe('low');
    });
  });

  describe('calculateWeightedScore', () => {
    it('calculates weighted average of factors', () => {
      const score = calculateWeightedScore({
        inputCompleteness: 0.8,
        aiSelfAssessment: 0.7,
        patternMatch: 0.9
      });

      expect(score).toBeGreaterThan(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('respects custom weights', () => {
      const factors = {
        inputCompleteness: 1.0,
        aiSelfAssessment: 0.0,
        patternMatch: 0.0
      };

      const inputOnlyScore = calculateWeightedScore(factors, {
        inputCompleteness: 1.0,
        aiSelfAssessment: 0.0,
        patternMatch: 0.0
      });

      expect(inputOnlyScore).toBe(100);
    });

    it('returns 0-100 range', () => {
      const lowScore = calculateWeightedScore({
        inputCompleteness: 0,
        aiSelfAssessment: 0,
        patternMatch: 0
      });

      const highScore = calculateWeightedScore({
        inputCompleteness: 1,
        aiSelfAssessment: 1,
        patternMatch: 1
      });

      expect(lowScore).toBe(0);
      expect(highScore).toBe(100);
    });
  });

  describe('generateClarifyingQuestions', () => {
    it('generates questions for low input completeness', () => {
      const questions = generateClarifyingQuestions(
        'Features',
        { inputCompleteness: 0.3, aiSelfAssessment: 0.8, patternMatch: 0.7 }
      );

      expect(questions.length).toBeGreaterThan(0);
      expect(questions.some(q => q.toLowerCase().includes('features'))).toBe(true);
    });

    it('generates questions for low pattern match', () => {
      const questions = generateClarifyingQuestions(
        'Architecture',
        { inputCompleteness: 0.8, aiSelfAssessment: 0.7, patternMatch: 0.3 }
      );

      expect(questions.some(q => q.includes('standard') || q.includes('pattern'))).toBe(true);
    });

    it('includes AI uncertain areas as questions', () => {
      const questions = generateClarifyingQuestions(
        'Test',
        { inputCompleteness: 0.5, aiSelfAssessment: 0.5, patternMatch: 0.5 },
        ['What is the deployment target?', 'Which database to use?']
      );

      expect(questions.some(q => q.includes('deployment') || q.includes('database'))).toBe(true);
    });

    it('limits to 5 questions', () => {
      const questions = generateClarifyingQuestions(
        'Test',
        { inputCompleteness: 0.2, aiSelfAssessment: 0.2, patternMatch: 0.2 },
        ['Q1?', 'Q2?', 'Q3?', 'Q4?', 'Q5?', 'Q6?', 'Q7?']
      );

      expect(questions.length).toBeLessThanOrEqual(5);
    });
  });

  describe('ConfidenceScorer class', () => {
    let scorer: ConfidenceScorer;

    beforeEach(() => {
      scorer = new ConfidenceScorer();
    });

    describe('calculateSectionConfidence', () => {
      it('returns valid SectionConfidence object', () => {
        const result = scorer.calculateSectionConfidence({
          sectionId: 'overview',
          sectionName: 'Overview',
          inputData: { description: 'Project overview' },
          aiSelfAssessment: 0.75
        });

        expect(result.sectionId).toBe('overview');
        expect(result.sectionName).toBe('Overview');
        expect(result.score).toBeGreaterThanOrEqual(0);
        expect(result.score).toBeLessThanOrEqual(100);
        expect(['high', 'medium', 'low']).toContain(result.tier);
        expect(result.factors).toBeDefined();
        expect(typeof result.needsReview).toBe('boolean');
      });

      it('generates clarifying questions for low tier', () => {
        const result = scorer.calculateSectionConfidence({
          sectionId: 'test',
          sectionName: 'Test Section',
          inputData: {},
          aiSelfAssessment: 0.2,
          patternMatchScore: 0.2
        });

        expect(result.tier).toBe('low');
        expect(result.clarifyingQuestions).toBeDefined();
        expect(result.clarifyingQuestions!.length).toBeGreaterThan(0);
      });

      it('marks needsReview for scores below warning threshold', () => {
        const highResult = scorer.calculateSectionConfidence({
          sectionId: 'test',
          sectionName: 'Test',
          inputData: { description: 'Long description '.repeat(50) },
          aiSelfAssessment: 0.9,
          patternMatchScore: 0.9
        });

        const lowResult = scorer.calculateSectionConfidence({
          sectionId: 'test2',
          sectionName: 'Test 2',
          inputData: {},
          aiSelfAssessment: 0.3,
          patternMatchScore: 0.3
        });

        expect(highResult.needsReview).toBe(false);
        expect(lowResult.needsReview).toBe(true);
      });
    });

    describe('aggregateConfidence', () => {
      it('calculates overall score from sections', () => {
        const sections = [
          scorer.calculateSectionConfidence({
            sectionId: 's1',
            sectionName: 'Section 1',
            inputData: { description: 'Test' },
            aiSelfAssessment: 0.9
          }),
          scorer.calculateSectionConfidence({
            sectionId: 's2',
            sectionName: 'Section 2',
            inputData: { description: 'Test' },
            aiSelfAssessment: 0.7
          })
        ];

        const result = scorer.aggregateConfidence(sections);

        expect(result.totalSections).toBe(2);
        expect(result.overallScore).toBeGreaterThan(0);
        expect(['high', 'medium', 'low']).toContain(result.overallTier);
      });

      it('identifies low confidence sections', () => {
        const lowSection = scorer.calculateSectionConfidence({
          sectionId: 'low',
          sectionName: 'Low Section',
          inputData: {},
          aiSelfAssessment: 0.2,
          patternMatchScore: 0.2
        });

        const result = scorer.aggregateConfidence([lowSection]);

        expect(result.lowConfidenceSections.length).toBe(1);
        expect(result.lowConfidenceSections[0].sectionId).toBe('low');
      });

      it('returns zeros for empty array', () => {
        const result = scorer.aggregateConfidence([]);

        expect(result.totalSections).toBe(0);
        expect(result.overallScore).toBe(0);
        expect(result.overallTier).toBe('low');
      });
    });

    describe('configuration', () => {
      it('allows custom config via constructor', () => {
        const customScorer = new ConfidenceScorer({
          warningThreshold: 80,
          errorThreshold: 60
        });

        expect(customScorer.getConfig().warningThreshold).toBe(80);
        expect(customScorer.getConfig().errorThreshold).toBe(60);
      });

      it('allows updating config', () => {
        scorer.updateConfig({ warningThreshold: 90 });
        expect(scorer.getConfig().warningThreshold).toBe(90);
      });
    });
  });
});
```

Create tests/ai-services/DependencyGraph.test.ts:

```typescript
import {
  DependencyGraph,
  detectImplicitDependencies,
  DetectedDependency
} from '../../src/analysis/DependencyGraph';
import {
  extractKeywords,
  checkKeywordDependency,
  findMatchingPattern
} from '../../src/analysis/KeywordExtractor';
import { AITask, TaskStatus, TaskPriority } from '../../src/domain/ai-types';

function createMockTask(id: string, title: string, description: string = ''): AITask {
  return {
    id,
    title,
    description,
    status: TaskStatus.PENDING,
    priority: TaskPriority.MEDIUM,
    complexity: 5,
    estimatedHours: 4,
    aiGenerated: true,
    subtasks: [],
    dependencies: [],
    acceptanceCriteria: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    tags: []
  };
}

describe('KeywordExtractor', () => {
  describe('extractKeywords', () => {
    it('extracts meaningful keywords from text', () => {
      const keywords = extractKeywords('Setup the database infrastructure and configure migrations');

      expect(keywords).toContain('setup');
      expect(keywords).toContain('database');
      expect(keywords).toContain('infrastructure');
      expect(keywords).toContain('configure');
      expect(keywords).toContain('migrations');
    });

    it('removes stop words', () => {
      const keywords = extractKeywords('The quick brown fox jumps over the lazy dog');

      expect(keywords).not.toContain('the');
      expect(keywords).not.toContain('over');
    });

    it('returns unique keywords', () => {
      const keywords = extractKeywords('database database database migration');

      expect(keywords.filter(k => k === 'database').length).toBe(1);
    });
  });

  describe('findMatchingPattern', () => {
    it('matches database-related keywords', () => {
      const pattern = findMatchingPattern(['database', 'schema', 'model']);

      expect(pattern).not.toBeNull();
      expect(pattern!.keywords).toContain('database');
    });

    it('matches API-related keywords', () => {
      const pattern = findMatchingPattern(['api', 'endpoint', 'controller']);

      expect(pattern).not.toBeNull();
      expect(pattern!.dependsOn.length).toBeGreaterThan(0);
    });

    it('returns null for no match', () => {
      const pattern = findMatchingPattern(['random', 'unrelated', 'words']);

      expect(pattern).toBeNull();
    });
  });

  describe('checkKeywordDependency', () => {
    it('detects database -> API dependency', () => {
      const taskAKeywords = ['database', 'schema', 'model'];
      const taskBKeywords = ['api', 'endpoint', 'controller'];

      const result = checkKeywordDependency(taskAKeywords, taskBKeywords);

      expect(result.likely).toBe(true);
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('detects API -> UI dependency', () => {
      const taskAKeywords = ['api', 'endpoint'];
      const taskBKeywords = ['frontend', 'component', 'ui'];

      const result = checkKeywordDependency(taskAKeywords, taskBKeywords);

      expect(result.likely).toBe(true);
    });

    it('returns not likely for unrelated tasks', () => {
      const taskAKeywords = ['documentation', 'readme'];
      const taskBKeywords = ['database', 'schema'];

      const result = checkKeywordDependency(taskAKeywords, taskBKeywords);

      expect(result.likely).toBe(false);
    });
  });
});

describe('DependencyGraph', () => {
  let graph: DependencyGraph;

  beforeEach(() => {
    graph = new DependencyGraph();
  });

  describe('addTask', () => {
    it('adds task to graph', () => {
      const task = createMockTask('task-1', 'Setup Database');
      graph.addTask(task);

      const analysis = graph.analyze();
      expect(analysis.orphanTasks).toContain('task-1');
    });

    it('adds explicit dependencies', () => {
      const task1 = createMockTask('task-1', 'Setup Database');
      const task2: AITask = {
        ...createMockTask('task-2', 'Create API'),
        dependencies: [{ id: 'task-1', type: 'depends_on' }]
      };

      graph.addTask(task1);
      graph.addTask(task2);

      const analysis = graph.analyze();
      expect(analysis.orphanTasks).toContain('task-1');
      expect(analysis.leafTasks).toContain('task-2');
    });
  });

  describe('detectImplicitDependencies', () => {
    it('detects infrastructure -> implementation dependencies', () => {
      graph.addTask(createMockTask('t1', 'Setup infrastructure', 'Configure the base infrastructure'));
      graph.addTask(createMockTask('t2', 'Create API endpoints', 'Build REST API endpoints'));

      const detected = graph.detectImplicitDependencies(0.3);

      expect(detected.length).toBeGreaterThan(0);
    });

    it('respects confidence threshold', () => {
      graph.addTask(createMockTask('t1', 'Task A'));
      graph.addTask(createMockTask('t2', 'Task B'));

      const lowThreshold = graph.detectImplicitDependencies(0.1);
      graph = new DependencyGraph();
      graph.addTask(createMockTask('t1', 'Task A'));
      graph.addTask(createMockTask('t2', 'Task B'));
      const highThreshold = graph.detectImplicitDependencies(0.9);

      expect(lowThreshold.length).toBeGreaterThanOrEqual(highThreshold.length);
    });
  });

  describe('detectCycles', () => {
    it('detects circular dependencies', () => {
      const task1 = createMockTask('t1', 'Task 1');
      const task2: AITask = {
        ...createMockTask('t2', 'Task 2'),
        dependencies: [{ id: 't1', type: 'depends_on' }]
      };
      const task3: AITask = {
        ...createMockTask('t3', 'Task 3'),
        dependencies: [{ id: 't2', type: 'depends_on' }]
      };

      graph.addTask(task1);
      graph.addTask(task2);
      graph.addTask(task3);

      // Manually add cycle
      graph.addDependency('t3', 't1', {
        type: 'depends_on',
        confidence: 1,
        reasoning: 'Manual cycle',
        isImplicit: false
      });

      const cycles = graph.detectCycles();
      expect(cycles.length).toBeGreaterThan(0);
    });

    it('returns empty for acyclic graph', () => {
      graph.addTask(createMockTask('t1', 'Task 1'));
      graph.addTask({
        ...createMockTask('t2', 'Task 2'),
        dependencies: [{ id: 't1', type: 'depends_on' }]
      });
      graph.addTask({
        ...createMockTask('t3', 'Task 3'),
        dependencies: [{ id: 't2', type: 'depends_on' }]
      });

      const cycles = graph.detectCycles();
      expect(cycles.length).toBe(0);
    });
  });

  describe('getExecutionOrder', () => {
    it('returns topologically sorted order', () => {
      graph.addTask(createMockTask('t1', 'First'));
      graph.addTask({
        ...createMockTask('t2', 'Second'),
        dependencies: [{ id: 't1', type: 'depends_on' }]
      });
      graph.addTask({
        ...createMockTask('t3', 'Third'),
        dependencies: [{ id: 't2', type: 'depends_on' }]
      });

      const order = graph.getExecutionOrder();

      expect(order.indexOf('t1')).toBeLessThan(order.indexOf('t2'));
      expect(order.indexOf('t2')).toBeLessThan(order.indexOf('t3'));
    });
  });

  describe('getParallelGroups', () => {
    it('groups independent tasks together', () => {
      graph.addTask(createMockTask('t1', 'Independent 1'));
      graph.addTask(createMockTask('t2', 'Independent 2'));
      graph.addTask({
        ...createMockTask('t3', 'Depends on both'),
        dependencies: [
          { id: 't1', type: 'depends_on' },
          { id: 't2', type: 'depends_on' }
        ]
      });

      const groups = graph.getParallelGroups();

      expect(groups[0]).toContain('t1');
      expect(groups[0]).toContain('t2');
      expect(groups[1]).toContain('t3');
    });
  });

  describe('analyze', () => {
    it('returns complete analysis result', () => {
      graph.addTask(createMockTask('t1', 'Root'));
      graph.addTask({
        ...createMockTask('t2', 'Child'),
        dependencies: [{ id: 't1', type: 'depends_on' }]
      });

      const result = graph.analyze();

      expect(result.executionOrder).toBeDefined();
      expect(result.criticalPath).toBeDefined();
      expect(result.parallelGroups).toBeDefined();
      expect(result.cycles).toBeDefined();
      expect(result.orphanTasks).toContain('t1');
      expect(result.leafTasks).toContain('t2');
    });
  });

  describe('exportForVisualization', () => {
    it('exports nodes and edges', () => {
      graph.addTask(createMockTask('t1', 'Task 1'));
      graph.addTask({
        ...createMockTask('t2', 'Task 2'),
        dependencies: [{ id: 't1', type: 'depends_on' }]
      });

      const exported = graph.exportForVisualization();

      expect(exported.nodes.length).toBe(2);
      expect(exported.edges.length).toBe(1);
      expect(exported.nodes[0]).toHaveProperty('id');
      expect(exported.nodes[0]).toHaveProperty('label');
      expect(exported.edges[0]).toHaveProperty('from');
      expect(exported.edges[0]).toHaveProperty('to');
    });
  });
});

describe('detectImplicitDependencies helper', () => {
  it('detects dependencies without instantiating graph', () => {
    const tasks: AITask[] = [
      createMockTask('t1', 'Setup database infrastructure'),
      createMockTask('t2', 'Create API endpoints for the service')
    ];

    const detected = detectImplicitDependencies(tasks, 0.3);

    expect(Array.isArray(detected)).toBe(true);
  });
});
```

Create tests/ai-services/EstimationCalibrator.test.ts:

```typescript
import {
  EstimationCalibrator,
  getComplexityBand,
  complexityToPoints,
  calculateRange,
  EstimationRecord
} from '../../src/analysis/EstimationCalibrator';
import { TaskComplexity } from '../../src/domain/ai-types';

describe('EstimationCalibrator helpers', () => {
  describe('getComplexityBand', () => {
    it('returns low for complexity 1-3', () => {
      expect(getComplexityBand(1)).toBe('low');
      expect(getComplexityBand(2)).toBe('low');
      expect(getComplexityBand(3)).toBe('low');
    });

    it('returns medium for complexity 4-6', () => {
      expect(getComplexityBand(4)).toBe('medium');
      expect(getComplexityBand(5)).toBe('medium');
      expect(getComplexityBand(6)).toBe('medium');
    });

    it('returns high for complexity 7-10', () => {
      expect(getComplexityBand(7)).toBe('high');
      expect(getComplexityBand(8)).toBe('high');
      expect(getComplexityBand(9)).toBe('high');
      expect(getComplexityBand(10)).toBe('high');
    });
  });

  describe('complexityToPoints', () => {
    it('maps complexity to Fibonacci-like points', () => {
      expect(complexityToPoints(1)).toBe(1);
      expect(complexityToPoints(3)).toBe(2);
      expect(complexityToPoints(5)).toBe(5);
      expect(complexityToPoints(7)).toBe(8);
      expect(complexityToPoints(10)).toBe(13);
    });
  });

  describe('calculateRange', () => {
    it('returns low and high range', () => {
      const range = calculateRange(5, 5 as TaskComplexity);

      expect(range.low).toBeLessThanOrEqual(5);
      expect(range.high).toBeGreaterThanOrEqual(5);
    });

    it('widens range for higher complexity', () => {
      const lowComplexRange = calculateRange(5, 2 as TaskComplexity);
      const highComplexRange = calculateRange(5, 9 as TaskComplexity);

      const lowWidth = lowComplexRange.high - lowComplexRange.low;
      const highWidth = highComplexRange.high - highComplexRange.low;

      expect(highWidth).toBeGreaterThan(lowWidth);
    });
  });
});

describe('EstimationCalibrator', () => {
  let calibrator: EstimationCalibrator;

  beforeEach(() => {
    calibrator = new EstimationCalibrator();
  });

  describe('recordEstimate', () => {
    it('records estimate and returns record', () => {
      const record = calibrator.recordEstimate({
        taskId: 'task-1',
        title: 'Test Task',
        estimatedPoints: 5,
        complexity: 5 as TaskComplexity
      });

      expect(record.taskId).toBe('task-1');
      expect(record.estimatedPoints).toBe(5);
      expect(record.complexityBand).toBe('medium');
      expect(record.estimatedAt).toBeDefined();
    });
  });

  describe('recordActual', () => {
    it('updates record with actual points', () => {
      calibrator.recordEstimate({
        taskId: 'task-1',
        title: 'Test',
        estimatedPoints: 5,
        complexity: 5 as TaskComplexity
      });

      const updated = calibrator.recordActual('task-1', 8);

      expect(updated).toBe(true);
    });

    it('returns false for unknown task', () => {
      const result = calibrator.recordActual('unknown', 5);
      expect(result).toBe(false);
    });
  });

  describe('estimate', () => {
    it('returns uncalibrated estimate without historical data', () => {
      const estimate = calibrator.estimate({
        complexity: 5 as TaskComplexity,
        title: 'Test Task'
      });

      expect(estimate.points).toBe(5); // Base points for complexity 5
      expect(estimate.calibrated).toBe(false);
      expect(estimate.range.low).toBeLessThanOrEqual(estimate.points);
      expect(estimate.range.high).toBeGreaterThanOrEqual(estimate.points);
    });

    it('applies calibration with sufficient data', () => {
      // Add 5 completed tasks with consistent underestimation
      for (let i = 0; i < 5; i++) {
        calibrator.recordEstimate({
          taskId: `task-${i}`,
          title: 'Test',
          estimatedPoints: 5,
          complexity: 5 as TaskComplexity
        });
        calibrator.recordActual(`task-${i}`, 10); // Actual is 2x estimate
      }

      const estimate = calibrator.estimate({
        complexity: 5 as TaskComplexity
      });

      expect(estimate.calibrated).toBe(true);
      expect(estimate.calibrationFactor).toBeGreaterThan(1);
      expect(estimate.points).toBeGreaterThan(5); // Should be adjusted up
    });

    it('includes reasoning in estimate', () => {
      const estimate = calibrator.estimate({
        complexity: 7 as TaskComplexity,
        title: 'Complex Task'
      });

      expect(estimate.reasoning).toBeDefined();
      expect(estimate.reasoning!.length).toBeGreaterThan(0);
    });
  });

  describe('getCalibrationFactor', () => {
    it('returns null without sufficient data', () => {
      const factor = calibrator.getCalibrationFactor('medium');
      expect(factor).toBeNull();
    });

    it('returns factor with sufficient data', () => {
      for (let i = 0; i < 5; i++) {
        calibrator.recordEstimate({
          taskId: `task-${i}`,
          title: 'Test',
          estimatedPoints: 5,
          complexity: 5 as TaskComplexity
        });
        calibrator.recordActual(`task-${i}`, 5); // Perfect accuracy
      }

      const factor = calibrator.getCalibrationFactor('medium');
      expect(factor).toBeCloseTo(1.0, 1);
    });
  });

  describe('getAccuracyStats', () => {
    it('returns statistics for all bands', () => {
      calibrator.recordEstimate({
        taskId: 't1',
        title: 'Low',
        estimatedPoints: 2,
        complexity: 2 as TaskComplexity
      });
      calibrator.recordActual('t1', 3);

      const stats = calibrator.getAccuracyStats();

      expect(stats.totalRecords).toBe(1);
      expect(stats.completedRecords).toBe(1);
      expect(stats.accuracyByBand).toHaveProperty('low');
      expect(stats.accuracyByBand).toHaveProperty('medium');
      expect(stats.accuracyByBand).toHaveProperty('high');
    });
  });

  describe('import/export', () => {
    it('exports and imports records', () => {
      calibrator.recordEstimate({
        taskId: 't1',
        title: 'Test',
        estimatedPoints: 5,
        complexity: 5 as TaskComplexity
      });

      const exported = calibrator.exportRecords();
      expect(exported.length).toBe(1);

      const newCalibrator = new EstimationCalibrator();
      newCalibrator.importRecords(exported);

      const stats = newCalibrator.getAccuracyStats();
      expect(stats.totalRecords).toBe(1);
    });

    it('recalculates factors on import', () => {
      const records: EstimationRecord[] = [];
      for (let i = 0; i < 5; i++) {
        records.push({
          taskId: `t${i}`,
          title: 'Test',
          estimatedPoints: 5,
          actualPoints: 10,
          complexityBand: 'medium',
          estimatedAt: new Date().toISOString(),
          completedAt: new Date().toISOString()
        });
      }

      calibrator.importRecords(records);

      const factor = calibrator.getCalibrationFactor('medium');
      expect(factor).toBeCloseTo(2.0, 1); // Actual was 2x estimate
    });
  });

  describe('constructor with historical records', () => {
    it('initializes with historical data', () => {
      const records: EstimationRecord[] = [
        {
          taskId: 't1',
          title: 'Test',
          estimatedPoints: 5,
          actualPoints: 5,
          complexityBand: 'medium',
          estimatedAt: new Date().toISOString(),
          completedAt: new Date().toISOString()
        }
      ];

      const newCalibrator = new EstimationCalibrator(records);
      const stats = newCalibrator.getAccuracyStats();

      expect(stats.totalRecords).toBe(1);
    });
  });
});
```

Create tests/ai-services/TemplateEngine.test.ts:

```typescript
import { TemplateEngine } from '../../src/services/templates/TemplateEngine';
import { TemplateParser, detectTemplateFormat, extractPlaceholders, extractMarkdownSections } from '../../src/services/templates/TemplateParser';
import { TemplateValidator } from '../../src/services/templates/TemplateValidator';
import { TemplateFormat } from '../../src/domain/template-types';

describe('TemplateParser', () => {
  describe('detectTemplateFormat', () => {
    it('detects markdown format from placeholders', () => {
      const content = '# {{title}}\n\n{{description}}';
      expect(detectTemplateFormat(content)).toBe('markdown');
    });

    it('detects json-schema format', () => {
      const content = JSON.stringify({
        $schema: 'http://json-schema.org/draft-07/schema#',
        type: 'object',
        properties: { title: { type: 'string' } }
      });
      expect(detectTemplateFormat(content)).toBe('json-schema');
    });

    it('detects example-based format from sample', () => {
      const content = JSON.stringify({ example: { title: 'Sample' } });
      expect(detectTemplateFormat(content)).toBe('example-based');
    });

    it('defaults to example-based for plain text', () => {
      const content = 'Just some plain text without placeholders';
      expect(detectTemplateFormat(content)).toBe('example-based');
    });
  });

  describe('extractPlaceholders', () => {
    it('extracts single placeholder', () => {
      const result = extractPlaceholders('Hello {{name}}');
      expect(result).toEqual(['name']);
    });

    it('extracts multiple unique placeholders', () => {
      const result = extractPlaceholders('{{a}} {{b}} {{a}}');
      expect(result).toEqual(['a', 'b']);
    });

    it('returns empty array for no placeholders', () => {
      expect(extractPlaceholders('no placeholders')).toEqual([]);
    });
  });

  describe('extractMarkdownSections', () => {
    it('extracts sections from markdown headers', () => {
      const content = '## Overview\nContent here\n## Features\nMore content';
      const sections = extractMarkdownSections(content);
      expect(sections.length).toBe(2);
      expect(sections[0].name).toBe('Overview');
      expect(sections[1].name).toBe('Features');
    });

    it('marks optional sections', () => {
      const content = '## Required Section\n\n## Optional Notes\n';
      const sections = extractMarkdownSections(content);
      expect(sections[0].required).toBe(true);
      expect(sections[1].required).toBe(false);
    });
  });

  describe('TemplateParser.parse', () => {
    let parser: TemplateParser;
    beforeEach(() => { parser = new TemplateParser(); });

    it('parses markdown template', () => {
      const result = parser.parse('## {{section}}\n{{content}}', 'Test');
      expect(result.format).toBe('markdown');
      expect(result.placeholders).toContain('section');
      expect(result.placeholders).toContain('content');
    });

    it('parses json-schema template', () => {
      const schema = JSON.stringify({
        type: 'object',
        properties: { title: { type: 'string', description: 'Title' } },
        required: ['title']
      });
      const result = parser.parse(schema);
      expect(result.format).toBe('json-schema');
      expect(result.sections.length).toBeGreaterThan(0);
    });
  });
});

describe('TemplateEngine', () => {
  let engine: TemplateEngine;
  beforeEach(() => { engine = new TemplateEngine(); });

  describe('compile and render', () => {
    it('renders simple template', () => {
      const output = engine.render('Hello {{name}}!', { name: 'World' });
      expect(output).toBe('Hello World!');
    });

    it('caches compiled templates', () => {
      engine.render('{{x}}', { x: 1 });
      engine.render('{{x}}', { x: 2 });
      // No error means caching works
    });

    it('handles missing placeholders gracefully', () => {
      const output = engine.render('{{a}} {{b}}', { a: 'A' });
      expect(output).toContain('A');
    });
  });

  describe('custom helpers', () => {
    it('list helper formats array as bullet list', () => {
      const output = engine.render('{{list items}}', { items: ['a', 'b'] });
      expect(output).toContain('- a');
      expect(output).toContain('- b');
    });

    it('numbered_list helper formats with numbers', () => {
      const output = engine.render('{{numbered_list items}}', { items: ['x', 'y'] });
      expect(output).toContain('1. x');
      expect(output).toContain('2. y');
    });

    it('join helper joins with separator', () => {
      const output = engine.render('{{join tags ", "}}', { tags: ['a', 'b', 'c'] });
      expect(output).toBe('a, b, c');
    });

    it('default helper provides fallback', () => {
      const output = engine.render('{{default value "fallback"}}', {});
      expect(output).toBe('fallback');
    });
  });

  describe('validateSyntax', () => {
    it('returns valid for correct template', () => {
      const result = engine.validateSyntax('{{name}}');
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('detects unclosed blocks', () => {
      const result = engine.validateSyntax('{{#if cond}}no closing');
      expect(result.valid).toBe(false);
    });
  });

  describe('preview', () => {
    it('generates preview with sample data', () => {
      const preview = engine.preview('Title: {{title}}\nBody: {{body}}');
      expect(preview).toContain('[title]');
      expect(preview).toContain('[body]');
    });
  });
});

describe('TemplateValidator', () => {
  let validator: TemplateValidator;
  beforeEach(() => { validator = new TemplateValidator(); });

  describe('validate', () => {
    it('validates correct template', () => {
      const template = '## Overview\n{{overview}}\n## Features\n{{features}}';
      const result = validator.validate(template, 'prd');
      expect(result.valid).toBe(true);
    });

    it('warns about missing sections', () => {
      const template = '## Overview\n{{overview}}';
      const result = validator.validate(template, 'prd');
      expect(result.warnings.length).toBeGreaterThan(0);
      expect(result.missingSections.length).toBeGreaterThan(0);
    });

    it('returns placeholders found', () => {
      const template = '{{a}} {{b}} {{c}}';
      const result = validator.validate(template, 'prd');
      expect(result.placeholders).toContain('a');
      expect(result.placeholders).toContain('b');
    });
  });

  describe('validateCoverage', () => {
    it('calculates coverage percentage', () => {
      const parsed = new TemplateParser().parse('## Overview\n## Features\n## Scope');
      const coverage = validator.validateCoverage(parsed, 'prd');
      expect(coverage.coveragePercent).toBeGreaterThan(0);
      expect(coverage.covered.length).toBeGreaterThan(0);
    });
  });

  describe('generateSampleData', () => {
    it('generates sample data for template', () => {
      const parsed = new TemplateParser().parse('## Features\n{{features}}');
      const sample = validator.generateSampleData(parsed);
      expect(sample).toHaveProperty('features');
    });
  });
});
```

Create tests/ai-services/PRDValidator.test.ts:

```typescript
import { PRDValidator } from '../../src/infrastructure/validation/PRDValidator';
import { ValidationRuleEngine, ValidationRule } from '../../src/infrastructure/validation/ValidationRuleEngine';
import { COMPLETENESS_RULES } from '../../src/infrastructure/validation/rules/CompletenessRules';
import { CLARITY_RULES } from '../../src/infrastructure/validation/rules/ClarityRules';
import { PRDDocument } from '../../src/domain/ai-types';

function createMinimalPRD(overrides: Partial<PRDDocument> = {}): PRDDocument {
  return {
    id: 'test-prd',
    title: 'Test PRD',
    overview: 'A short overview',
    objectives: ['Objective 1'],
    features: [],
    scope: { inScope: [], outOfScope: [] },
    targetUsers: [],
    successMetrics: [],
    technicalRequirements: [],
    timeline: '',
    author: 'test',
    version: '1.0',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    ...overrides
  } as PRDDocument;
}

describe('ValidationRuleEngine', () => {
  let engine: ValidationRuleEngine;
  beforeEach(() => { engine = new ValidationRuleEngine(); });

  describe('registerRule', () => {
    it('registers a single rule', () => {
      const rule: ValidationRule = {
        id: 'TEST-001',
        name: 'Test Rule',
        description: 'Test',
        layer: 'builtin',
        severity: 'minor',
        category: 'completeness',
        enabled: true,
        check: () => ({ passed: true, message: 'OK' })
      };
      engine.registerRule(rule);
      expect(engine.getRules().length).toBe(1);
    });

    it('registers multiple rules', () => {
      engine.registerRules(COMPLETENESS_RULES);
      expect(engine.getRules().length).toBe(COMPLETENESS_RULES.length);
    });
  });

  describe('validate', () => {
    beforeEach(() => {
      engine.registerRules(COMPLETENESS_RULES);
    });

    it('runs all enabled rules', () => {
      const prd = createMinimalPRD({ overview: 'A'.repeat(150), objectives: ['O1', 'O2'] });
      const result = engine.validate(prd);
      expect(result.totalRules).toBeGreaterThan(0);
    });

    it('calculates score based on passed rules', () => {
      const prd = createMinimalPRD();
      const result = engine.validate(prd);
      expect(result.score).toBeGreaterThanOrEqual(0);
      expect(result.score).toBeLessThanOrEqual(100);
    });

    it('counts issues by severity', () => {
      const prd = createMinimalPRD();
      const result = engine.validate(prd);
      expect(result.criticalIssues).toBeDefined();
      expect(result.majorIssues).toBeDefined();
      expect(result.minorIssues).toBeDefined();
    });
  });

  describe('layer management', () => {
    it('enables and disables layers', () => {
      engine.enableLayer('standard');
      engine.disableLayer('standard');
      // builtin cannot be disabled
      engine.disableLayer('builtin');
    });

    it('skips rules from disabled layers', () => {
      const customRule: ValidationRule = {
        id: 'CUSTOM-001',
        name: 'Custom',
        description: 'Test',
        layer: 'custom',
        severity: 'minor',
        category: 'completeness',
        enabled: true,
        check: () => ({ passed: false, message: 'Fail' })
      };
      engine.registerRule(customRule);
      const prd = createMinimalPRD();
      const result = engine.validate(prd);
      // Custom layer not enabled, so rule shouldn't run
      expect(result.results.find(r => r.rule.id === 'CUSTOM-001')).toBeUndefined();
    });
  });
});

describe('PRDValidator', () => {
  let validator: PRDValidator;
  beforeEach(() => { validator = new PRDValidator(); });

  describe('validate', () => {
    it('validates a complete PRD', () => {
      const prd = createMinimalPRD({
        overview: 'A comprehensive overview that describes the project in detail. '.repeat(5),
        objectives: ['Objective 1', 'Objective 2'],
        features: [{
          id: 'f1',
          title: 'Feature 1',
          description: 'A detailed description of the feature that is at least 50 characters long',
          priority: 'high',
          acceptanceCriteria: ['AC1'],
          userStories: ['As a user, I want...']
        }],
        scope: { inScope: ['In scope item'], outOfScope: ['Out of scope item'] },
        targetUsers: [{ name: 'User', description: 'A user', goals: ['Goal 1'] }],
        successMetrics: ['Metric 1']
      });
      const result = validator.validate(prd);
      expect(result.passedRules).toBeGreaterThan(0);
    });

    it('fails validation for minimal PRD', () => {
      const prd = createMinimalPRD();
      const result = validator.validate(prd);
      expect(result.criticalIssues).toBeGreaterThan(0);
    });
  });

  describe('built-in rules', () => {
    it('has 13 built-in rules (8 completeness + 5 clarity)', () => {
      const rules = validator.getRules();
      expect(rules.length).toBe(13);
    });

    it('checks overview length (BR-001)', () => {
      const shortPRD = createMinimalPRD({ overview: 'Short' });
      const longPRD = createMinimalPRD({ overview: 'A'.repeat(150) });

      const shortResult = validator.validate(shortPRD);
      const longResult = validator.validate(longPRD);

      const shortBR001 = shortResult.results.find(r => r.rule.id === 'BR-001');
      const longBR001 = longResult.results.find(r => r.rule.id === 'BR-001');

      expect(shortBR001?.result.passed).toBe(false);
      expect(longBR001?.result.passed).toBe(true);
    });

    it('checks objectives count (BR-002)', () => {
      const onePRD = createMinimalPRD({ objectives: ['One'] });
      const twoPRD = createMinimalPRD({ objectives: ['One', 'Two'] });

      expect(validator.validate(onePRD).results.find(r => r.rule.id === 'BR-002')?.result.passed).toBe(false);
      expect(validator.validate(twoPRD).results.find(r => r.rule.id === 'BR-002')?.result.passed).toBe(true);
    });

    it('checks for vague language (CL-003)', () => {
      const vaguePRD = createMinimalPRD({ objectives: ['Improve performance', 'Make it better'] });
      const specificPRD = createMinimalPRD({ objectives: ['Reduce load time by 50%', 'Increase throughput to 1000 rps'] });

      expect(validator.validate(vaguePRD).results.find(r => r.rule.id === 'CL-003')?.result.passed).toBe(false);
      expect(validator.validate(specificPRD).results.find(r => r.rule.id === 'CL-003')?.result.passed).toBe(true);
    });
  });

  describe('getValidationSummary', () => {
    it('formats summary with score and issues', () => {
      const prd = createMinimalPRD();
      const result = validator.validate(prd);
      const summary = validator.getValidationSummary(result);

      expect(summary).toContain('PRD Validation Score');
      expect(summary).toContain('Status');
      expect(summary).toContain('Rules');
    });
  });

  describe('addRule', () => {
    it('allows adding custom rules', () => {
      const customRule: ValidationRule = {
        id: 'CUSTOM-001',
        name: 'Custom Rule',
        description: 'Test',
        layer: 'custom',
        severity: 'minor',
        category: 'completeness',
        enabled: true,
        check: () => ({ passed: true, message: 'OK' })
      };
      validator.addRule(customRule);
      validator.enableCustomRules();
      expect(validator.getRules().length).toBe(14);
    });
  });

  describe('autoFix', () => {
    it('returns unfixable issues for rules without autoFix', () => {
      const prd = createMinimalPRD();
      const result = validator.autoFix(prd);
      expect(result.unfixableIssues.length).toBeGreaterThan(0);
    });
  });
});

describe('Completeness Rules', () => {
  it('exports 8 completeness rules', () => {
    expect(COMPLETENESS_RULES.length).toBe(8);
  });

  it('all rules have required fields', () => {
    COMPLETENESS_RULES.forEach(rule => {
      expect(rule.id).toBeDefined();
      expect(rule.name).toBeDefined();
      expect(rule.category).toBe('completeness');
      expect(typeof rule.check).toBe('function');
    });
  });
});

describe('Clarity Rules', () => {
  it('exports 5 clarity rules', () => {
    expect(CLARITY_RULES.length).toBe(5);
  });

  it('all rules have required fields', () => {
    CLARITY_RULES.forEach(rule => {
      expect(rule.id).toBeDefined();
      expect(rule.name).toBeDefined();
      expect(rule.category).toBe('clarity');
      expect(typeof rule.check).toBe('function');
    });
  });
});
```
  </action>
  <verify>
Run: `npm test -- --testPathPattern="(ConfidenceScorer|DependencyGraph|EstimationCalibrator)" --passWithNoTests`
Verify tests run (may fail initially until code is implemented)
  </verify>
  <done>
ConfidenceScorer.test.ts has 20+ tests covering calculateInputCompleteness, scoring, aggregation.
DependencyGraph.test.ts has 20+ tests covering keyword extraction, graph analysis, cycles.
EstimationCalibrator.test.ts has 15+ tests covering estimation, calibration, import/export.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update documentation</name>
  <files>docs/TOOLS.md, .planning/STATUS.md</files>
  <action>
Update docs/TOOLS.md - add new section for AI Enhancement features after the existing tool categories:

```markdown
## AI Enhancement Services (Phase 9)

### Confidence Scoring

The AI generation services now include per-section confidence scoring:

- **ConfidenceScorer**: Calculates multi-factor confidence (0-100) for AI-generated content
  - Input completeness (description length, examples, constraints)
  - AI self-assessment (model's own certainty)
  - Pattern matching (similarity to known successful patterns)

- **Confidence Tiers**:
  - High (70-100): Content is reliable
  - Medium (50-69): Review recommended
  - Low (0-49): Clarifying questions generated

#### Example Usage

```typescript
const result = await prdService.generatePRDWithConfidence({
  projectIdea: 'Build a task management app',
  projectName: 'TaskFlow',
  author: 'developer',
  confidenceConfig: { warningThreshold: 75 }
});

// Access confidence per section
result.sectionConfidence.forEach(section => {
  console.log(`${section.sectionName}: ${section.score}% (${section.tier})`);
  if (section.clarifyingQuestions) {
    console.log('Questions:', section.clarifyingQuestions);
  }
});
```

### Template Customization

PRD and task templates support multiple formats:

- **Markdown**: `{{placeholder}}` syntax with sections
- **JSON Schema**: Structured field definitions
- **Example-based**: Learn from sample documents

```typescript
const engine = new TemplateEngine();
const template = engine.parse(markdownTemplate);
const output = engine.render(template, { projectName: 'MyApp' });
```

### PRD Validation

Built-in validation rules check PRD quality:

- **Completeness** (8 rules): Overview, objectives, features, metrics
- **Clarity** (5 rules): Descriptions, acceptance criteria, vague language

```typescript
const validator = new PRDValidator();
const results = validator.validate(prd);
console.log(validator.getValidationSummary(results));
```

### Task Dependency Analysis

Graph-based dependency detection:

- **Explicit**: Defined in task dependencies
- **Implicit**: Auto-detected via keyword analysis
- **Analysis**: Execution order, critical path, parallel groups

```typescript
const graph = new DependencyGraph();
graph.addTasks(tasks);
graph.detectImplicitDependencies(0.5);
const analysis = graph.analyze();
```

### Effort Estimation

Calibrated story point estimation:

- **Base**: Complexity (1-10)  Story Points (Fibonacci)
- **Calibration**: Learns from actual vs estimated
- **Range**: Low/high estimates with confidence

```typescript
const calibrator = new EstimationCalibrator(historicalRecords);
const estimate = calibrator.estimate({ complexity: 5 });
console.log(`${estimate.points} points (${estimate.confidence}% confident)`);
```
```

Update .planning/STATUS.md to reflect Phase 9 completion. Update the phase status table and add Phase 9 summary:

```markdown
## Phase 9 Completion Summary

**Phase 9: AI PRD and Task Enhancement** - Complete

| Plan | Name | Status | Key Results |
|------|------|--------|-------------|
| 09-01 | Confidence Types and Scoring | Complete | SectionConfidence types, ConfidenceScorer service |
| 09-02 | Template and Validation | Complete | TemplateEngine, PRDValidator with 13 rules |
| 09-03 | Generation Integration | Complete | DependencyGraph, EstimationCalibrator, PRD confidence |
| 09-04 | Testing and Documentation | Complete | 60+ tests, docs updated |

**Phase 9 Verified:**

| Requirement | Status |
|-------------|--------|
| AI-01: Improve feature extraction accuracy | PASS |
| AI-02: Add confidence scores to PRD sections | PASS |
| AI-03: Support PRD templates customization | PASS |
| AI-04: Add PRD validation against best practices | PASS |
| AI-05: Improve task complexity estimation | PASS |
| AI-06: Better dependency detection | PASS |
| AI-07: Add effort estimation to tasks | PASS |
| AI-08: Support task templates | PASS |

**Key deliverables:**
- handlebars ^4.7.8, graphlib ^2.1.8 installed
- ConfidenceScorer: Multi-factor confidence with tiered output
- TemplateEngine: Handlebars wrapper with custom helpers
- TemplateParser: Auto-detect markdown/json/example formats
- TemplateValidator: Syntax and coverage validation
- PRDValidator: 13 built-in rules (8 completeness + 5 clarity)
- DependencyGraph: Graph analysis with cycle detection
- KeywordExtractor: NLP-based implicit dependency detection
- EstimationCalibrator: Story point estimation with historical calibration
- PRDGenerationService.generatePRDWithConfidence
- TaskGenerationService.generateTasksWithAnalysis
- Test suite: 60+ new tests
```
  </action>
  <verify>
Review docs/TOOLS.md for accurate documentation of new features
Review .planning/STATUS.md for accurate phase completion status
  </verify>
  <done>
docs/TOOLS.md has section documenting AI Enhancement Services with examples.
.planning/STATUS.md updated with Phase 9 completion summary and requirement verification.
  </done>
</task>

</tasks>

<verification>
1. Run `npm test` - all tests pass
2. Run `npx tsc --noEmit` - no TypeScript errors
3. Verify TaskGenerationService.generateTasksWithAnalysis returns effort estimates
4. Verify tests/ai-services/ has new test files with 60+ tests total
5. Verify docs/TOOLS.md documents AI enhancement features
6. Verify .planning/STATUS.md shows Phase 9 complete
</verification>

<success_criteria>
- TaskGenerationService has generateTasksWithAnalysis returning TaskGenerationResult
- TaskGenerationResult includes effortEstimate and detectedDependencies per task
- recordActualEffort enables calibration feedback loop
- ConfidenceScorer.test.ts has 20+ tests
- DependencyGraph.test.ts has 20+ tests
- EstimationCalibrator.test.ts has 15+ tests
- docs/TOOLS.md documents confidence, templates, validation, dependencies, estimation
- .planning/STATUS.md confirms all 8 AI requirements complete
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-prd-task-enhancement/09-04-SUMMARY.md`
</output>
