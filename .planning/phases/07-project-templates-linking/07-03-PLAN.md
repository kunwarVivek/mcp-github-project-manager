---
phase: 07-project-templates-linking
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/infrastructure/tools/project-linking-tools.ts
  - src/infrastructure/tools/ToolSchemas.ts
  - src/infrastructure/tools/ToolRegistry.ts
autonomous: true

must_haves:
  truths:
    - "link_project_to_repository creates project-repo linkage"
    - "unlink_project_from_repository removes project-repo linkage"
    - "link_project_to_team creates project-team linkage"
    - "unlink_project_from_team removes project-team linkage"
    - "list_linked_repositories returns paginated repo list"
    - "list_linked_teams returns paginated team list"
  artifacts:
    - path: "src/infrastructure/tools/project-linking-tools.ts"
      provides: "6 MCP tool definitions and executors for linking operations"
      exports: ["linkProjectToRepositoryTool", "listLinkedRepositoriesTool", "executeLinkProjectToRepository"]
    - path: "src/infrastructure/tools/ToolRegistry.ts"
      provides: "Tool registration for linking tools"
      contains: "link_project_to_repository"
  key_links:
    - from: "project-linking-tools.ts"
      to: "project-template-linking-schemas.ts"
      via: "import schemas"
      pattern: "import.*project-template-linking-schemas"
    - from: "ToolRegistry.ts"
      to: "project-linking-tools.ts"
      via: "import and registration"
      pattern: "import.*project-linking-tools"
---

<objective>
Create 6 MCP tools for project linking operations (GHAPI-13 to GHAPI-18).

Purpose: Enable MCP clients to link/unlink GitHub projects to repositories and teams.
Output: 6 fully-annotated MCP tools with schemas, executors, and proper registration.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-project-templates-linking/07-RESEARCH.md
@.planning/phases/07-project-templates-linking/07-01-SUMMARY.md
@src/infrastructure/tools/sub-issue-tools.ts
@src/infrastructure/tools/annotations/tool-annotations.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create linking tool definitions</name>
  <files>src/infrastructure/tools/project-linking-tools.ts</files>
  <action>
Create project-linking-tools.ts following the sub-issue-tools.ts pattern:

**Helper Functions:**

1. `createFactory(owner, repo)` - Creates GitHubRepositoryFactory
2. `resolveRepositoryId(factory, owner, repo)` - Resolves repo to node ID:
   ```graphql
   query ResolveRepositoryId($owner: String!, $name: String!) {
     repository(owner: $owner, name: $name) { id }
   }
   ```
3. `resolveTeamId(factory, orgLogin, teamSlug)` - Resolves team to node ID:
   ```graphql
   query ResolveTeamId($orgLogin: String!, $teamSlug: String!) {
     organization(login: $orgLogin) { team(slug: $teamSlug) { id } }
   }
   ```

**Tool 1: link_project_to_repository (GHAPI-13)**
- name: "link_project_to_repository"
- title: "Link Project to Repository"
- description: "Links a GitHub project to a repository. Items from the repository can be added to the project."
- annotations: ANNOTATION_PATTERNS.updateIdempotent
- schema: LinkProjectToRepositoryInputSchema
- outputSchema: LinkedRepositoryOutputSchema

Executor `executeLinkProjectToRepository`:
1. Resolve owner/repo to repository node ID
2. Execute linkProjectV2ToRepository mutation:
   ```graphql
   mutation LinkProjectV2ToRepository($input: LinkProjectV2ToRepositoryInput!) {
     linkProjectV2ToRepository(input: $input) {
       repository { id name nameWithOwner url description }
     }
   }
   ```
3. Return structured result

**Tool 2: unlink_project_from_repository (GHAPI-14)**
- name: "unlink_project_from_repository"
- title: "Unlink Project from Repository"
- description: "Removes a repository linkage from a project."
- annotations: ANNOTATION_PATTERNS.delete
- schema: UnlinkProjectFromRepositoryInputSchema
- outputSchema: UnlinkOperationOutputSchema

Executor `executeUnlinkProjectFromRepository`:
1. Resolve owner/repo to repository node ID
2. Execute unlinkProjectV2FromRepository mutation
3. Return success message

**Tool 3: link_project_to_team (GHAPI-15)**
- name: "link_project_to_team"
- title: "Link Project to Team"
- description: "Links a GitHub project to a team. Team members will have access to the project."
- annotations: ANNOTATION_PATTERNS.updateIdempotent
- schema: LinkProjectToTeamInputSchema
- outputSchema: LinkedTeamOutputSchema

Executor `executeLinkProjectToTeam`:
1. Resolve org/teamSlug to team node ID
2. Execute linkProjectV2ToTeam mutation:
   ```graphql
   mutation LinkProjectV2ToTeam($input: LinkProjectV2ToTeamInput!) {
     linkProjectV2ToTeam(input: $input) {
       team { id name slug description }
     }
   }
   ```
3. Return structured result

**Tool 4: unlink_project_from_team (GHAPI-16)**
- name: "unlink_project_from_team"
- title: "Unlink Project from Team"
- description: "Removes a team linkage from a project."
- annotations: ANNOTATION_PATTERNS.delete
- schema: UnlinkProjectFromTeamInputSchema
- outputSchema: UnlinkOperationOutputSchema

**Tool 5: list_linked_repositories (GHAPI-17)**
- name: "list_linked_repositories"
- title: "List Linked Repositories"
- description: "Lists all repositories linked to a project."
- annotations: ANNOTATION_PATTERNS.readOnly
- schema: ListLinkedRepositoriesInputSchema
- outputSchema: LinkedRepositoriesListOutputSchema

Executor `executeListLinkedRepositories`:
1. Query project's repositories connection:
   ```graphql
   query ListLinkedRepositories($projectId: ID!, $first: Int!, $after: String) {
     node(id: $projectId) {
       ... on ProjectV2 {
         repositories(first: $first, after: $after) {
           nodes { id name nameWithOwner url description }
           pageInfo { hasNextPage endCursor }
           totalCount
         }
       }
     }
   }
   ```
2. Return paginated list

**Tool 6: list_linked_teams (GHAPI-18)**
- name: "list_linked_teams"
- title: "List Linked Teams"
- description: "Lists all teams linked to a project."
- annotations: ANNOTATION_PATTERNS.readOnly
- schema: ListLinkedTeamsInputSchema
- outputSchema: LinkedTeamsListOutputSchema

Executor `executeListLinkedTeams`:
1. Query project's teams connection:
   ```graphql
   query ListLinkedTeams($projectId: ID!, $first: Int!, $after: String) {
     node(id: $projectId) {
       ... on ProjectV2 {
         teams(first: $first, after: $after) {
           nodes { id name slug description }
           pageInfo { hasNextPage endCursor }
           totalCount
         }
       }
     }
   }
   ```
2. Return paginated list

Export all 6 tool definitions and 6 executor functions.
  </action>
  <verify>TypeScript compiles. `grep -c "ToolDefinition" src/infrastructure/tools/project-linking-tools.ts` shows 6 tool definitions.</verify>
  <done>project-linking-tools.ts exports 6 linking tool definitions with executors.</done>
</task>

<task type="auto">
  <name>Task 2: Register linking tools</name>
  <files>src/infrastructure/tools/ToolSchemas.ts, src/infrastructure/tools/ToolRegistry.ts</files>
  <action>
**In ToolSchemas.ts:**
1. Import linking tools from project-linking-tools.ts:
   ```typescript
   export {
     linkProjectToRepositoryTool,
     unlinkProjectFromRepositoryTool,
     linkProjectToTeamTool,
     unlinkProjectFromTeamTool,
     listLinkedRepositoriesTool,
     listLinkedTeamsTool,
   } from "./project-linking-tools.js";
   ```

**In ToolRegistry.ts:**
1. Import linking tools and executors:
   ```typescript
   import {
     linkProjectToRepositoryTool,
     unlinkProjectFromRepositoryTool,
     linkProjectToTeamTool,
     unlinkProjectFromTeamTool,
     listLinkedRepositoriesTool,
     listLinkedTeamsTool,
     executeLinkProjectToRepository,
     executeUnlinkProjectFromRepository,
     executeLinkProjectToTeam,
     executeUnlinkProjectFromTeam,
     executeListLinkedRepositories,
     executeListLinkedTeams,
   } from "./project-linking-tools.js";
   ```

2. Add to tools array in registerTools():
   ```typescript
   linkProjectToRepositoryTool,
   unlinkProjectFromRepositoryTool,
   linkProjectToTeamTool,
   unlinkProjectFromTeamTool,
   listLinkedRepositoriesTool,
   listLinkedTeamsTool,
   ```

3. Add executor mappings in executeTool switch:
   ```typescript
   case "link_project_to_repository":
     return executeLinkProjectToRepository(args);
   case "unlink_project_from_repository":
     return executeUnlinkProjectFromRepository(args);
   case "link_project_to_team":
     return executeLinkProjectToTeam(args);
   case "unlink_project_from_team":
     return executeUnlinkProjectFromTeam(args);
   case "list_linked_repositories":
     return executeListLinkedRepositories(args);
   case "list_linked_teams":
     return executeListLinkedTeams(args);
   ```
  </action>
  <verify>TypeScript compiles. `npm run build` succeeds. `grep -c "link" src/infrastructure/tools/ToolRegistry.ts` shows all tools registered.</verify>
  <done>All 6 linking tools registered in ToolRegistry with executors wired.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no TypeScript errors
2. All 6 tools have proper annotations (2 delete, 2 updateIdempotent, 2 readOnly)
3. All tools have output schemas matching Zod schemas
4. ToolRegistry registers all 6 linking tools
5. Helper functions for resolving repo and team IDs work correctly
</verification>

<success_criteria>
- 6 tool definitions with annotations, schemas, and outputSchemas
- 6 executor functions that call GraphQL directly via factory
- resolveRepositoryId and resolveTeamId helpers
- All tools registered in ToolRegistry
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-project-templates-linking/07-03-SUMMARY.md`
</output>
