---
phase: 03-type-safety
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/tools/ToolRegistry.ts
  - src/infrastructure/github/types.ts
autonomous: true

must_haves:
  truths:
    - "Zod type introspection uses public API or properly typed access"
    - "Type guard implementation uses proper narrowing without as any"
    - "TypeScript compiler accepts all type narrowing patterns"
  artifacts:
    - path: "src/infrastructure/tools/ToolRegistry.ts"
      provides: "Tool schema handling with typed Zod access"
      pattern: "instanceof ZodOptional|ZodObject"
    - path: "src/infrastructure/github/types.ts"
      provides: "Type guards with proper narrowing"
      pattern: "isRecord\\(e\\)"
  key_links:
    - from: "ToolRegistry.ts"
      to: "Zod types"
      via: "instanceof checks"
      pattern: "instanceof Zod"
---

<objective>
Fix Zod internal API access and improve type guard narrowing patterns.

Purpose: Replace internal `._def.typeName` access with public Zod API patterns and fix type guard implementation to use proper narrowing.
Output: ToolRegistry uses `instanceof` checks, types.ts uses proper type narrowing without `as any`.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-safety/03-RESEARCH.md

@src/infrastructure/tools/ToolRegistry.ts
@src/infrastructure/github/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Zod internal API access with instanceof checks</name>
  <files>src/infrastructure/tools/ToolRegistry.ts</files>
  <action>
Replace the `._def.typeName` access patterns with proper `instanceof` checks:

**Line 340:**
Current: `if ((zodType as any)._def.typeName !== "ZodOptional")`
Replace with:
```typescript
import { ZodOptional } from 'zod';
// ...
if (!(zodType instanceof ZodOptional))
```

**Line 405:**
Current: `if ((fieldType as any)._def.typeName !== "ZodOptional")`
Replace with:
```typescript
if (!(fieldType instanceof ZodOptional))
```

Add the necessary Zod type imports at the top of the file:
```typescript
import { z, ZodOptional, ZodObject, ZodType } from 'zod';
```

If `instanceof` doesn't work due to Zod's internal structure, use the alternative pattern:
```typescript
// Check if the type has an innerType (which optional types have)
if (!('_def' in zodType) || zodType._def.typeName !== 'ZodOptional')
```

With proper typing:
```typescript
interface ZodTypeDef {
  typeName: string;
}

function isZodOptional(zodType: ZodType): boolean {
  return '_def' in zodType &&
         typeof (zodType as { _def: ZodTypeDef })._def?.typeName === 'string' &&
         (zodType as { _def: ZodTypeDef })._def.typeName === 'ZodOptional';
}
```

Choose the approach that compiles cleanly with no `as any`.
  </action>
  <verify>
```bash
# Verify no as any for Zod type access
echo "=== ToolRegistry Zod as any ==="
grep -n "as any.*_def" src/infrastructure/tools/ToolRegistry.ts && echo "FAIL" || echo "PASS"
grep -n "zodType as any" src/infrastructure/tools/ToolRegistry.ts && echo "FAIL" || echo "PASS"
grep -n "fieldType as any" src/infrastructure/tools/ToolRegistry.ts && echo "FAIL" || echo "PASS"
```
  </verify>
  <done>ToolRegistry accesses Zod type information without `as any` casts</done>
</task>

<task type="auto">
  <name>Task 2: Fix type guard narrowing in types.ts</name>
  <files>src/infrastructure/github/types.ts</files>
  <action>
Fix the type guard implementation at lines 200-202 that uses `as any`:

Current code:
```typescript
Array.isArray((error as any).errors) &&
(error as any).errors.every((e: unknown) =>
  isRecord(e) && typeof (e as any).message === 'string'
```

Replace with proper type narrowing. First, add a helper type guard:

```typescript
function hasErrorsArray(obj: unknown): obj is { errors: unknown[] } {
  return typeof obj === 'object' &&
         obj !== null &&
         'errors' in obj &&
         Array.isArray((obj as { errors: unknown }).errors);
}

function isErrorWithMessage(e: unknown): e is { message: string } {
  return isRecord(e) && 'message' in e && typeof e.message === 'string';
}
```

Then update the check:
```typescript
hasErrorsArray(error) &&
error.errors.every(isErrorWithMessage)
```

This eliminates all three `as any` usages in the type guard while maintaining the same validation logic.
  </action>
  <verify>
```bash
# Verify no as any in type guard
echo "=== types.ts type guard as any ==="
grep -n "error as any" src/infrastructure/github/types.ts && echo "FAIL" || echo "PASS"
grep -n "e as any" src/infrastructure/github/types.ts && echo "FAIL" || echo "PASS"

# Verify helper functions exist
grep -n "hasErrorsArray\|isErrorWithMessage" src/infrastructure/github/types.ts
```
  </verify>
  <done>types.ts type guards use proper narrowing without `as any`</done>
</task>

<task type="auto">
  <name>Task 3: Verify TypeScript compilation and run tests</name>
  <files>src/infrastructure/tools/ToolRegistry.ts, src/infrastructure/github/types.ts</files>
  <action>
Run TypeScript compilation to verify no type errors were introduced.
Run the test suite to ensure existing functionality is preserved.

These changes affect core infrastructure, so thorough verification is important.
  </action>
  <verify>
```bash
cd /Users/vivek/jet/mcp-github-project-manager && npx tsc --noEmit && echo "TypeScript compilation: PASS"
cd /Users/vivek/jet/mcp-github-project-manager && npm test 2>&1 | tail -20
```
  </verify>
  <done>TypeScript compiles without errors, all tests pass</done>
</task>

</tasks>

<verification>
```bash
cd /Users/vivek/jet/mcp-github-project-manager

# Verify as any removed
echo "=== ToolRegistry as any count ==="
grep -c "as any" src/infrastructure/tools/ToolRegistry.ts || echo "0"

echo "=== types.ts as any in error guards ==="
grep -n "as any" src/infrastructure/github/types.ts | grep -E "(error|\.errors)" || echo "None found"

# TypeScript compilation
npx tsc --noEmit && echo "TypeScript: PASS" || echo "TypeScript: FAIL"

# Tests pass
npm test 2>&1 | grep -E "(passed|failed|Tests:)"
```
</verification>

<success_criteria>
1. Zero `as any` for Zod type introspection in ToolRegistry.ts
2. Zero `as any` in error type guards in types.ts
3. TypeScript compiles without errors
4. All tests pass
5. 5 fewer `as any` assertions in infrastructure code
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-safety/03-03-SUMMARY.md`
</output>
