---
phase: 11-ai-issue-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/services/ai/DuplicateDetectionService.ts
  - src/services/ai/RelatedIssueLinkingService.ts
  - src/cache/EmbeddingCache.ts
autonomous: true

must_haves:
  truths:
    - "Duplicate detection uses embeddings for semantic similarity"
    - "Duplicates are tiered by confidence (high: auto-link, medium: flag for review, low: ignore)"
    - "Related issues are categorized by relationship type (semantic, dependency, component)"
    - "Embeddings are cached to avoid recomputation on every request"
    - "Services fall back to keyword matching when embedding API unavailable"
  artifacts:
    - path: "src/services/ai/DuplicateDetectionService.ts"
      provides: "Embedding-based duplicate issue detection"
      exports: ["DuplicateDetectionService"]
    - path: "src/services/ai/RelatedIssueLinkingService.ts"
      provides: "Multi-type relationship detection between issues"
      exports: ["RelatedIssueLinkingService"]
    - path: "src/cache/EmbeddingCache.ts"
      provides: "In-memory cache for issue embeddings with optional persistence"
      exports: ["EmbeddingCache"]
  key_links:
    - from: "src/services/ai/DuplicateDetectionService.ts"
      to: "ai"
      via: "embed, embedMany, cosineSimilarity"
      pattern: "import.*embed.*from.*ai"
    - from: "src/services/ai/DuplicateDetectionService.ts"
      to: "src/cache/EmbeddingCache.ts"
      via: "EmbeddingCache for caching"
      pattern: "import.*EmbeddingCache"
---

<objective>
Create AI services for duplicate detection (AI-19) and related issue linking (AI-20).

Purpose: Implement semantic similarity using Vercel AI SDK embeddings for finding duplicates and related issues. These services use embedding-based similarity with fallback to keyword matching.

Output:
- `src/services/ai/DuplicateDetectionService.ts` - Embedding-based duplicate detection with tiered response
- `src/services/ai/RelatedIssueLinkingService.ts` - Multi-type relationship detection
- `src/cache/EmbeddingCache.ts` - In-memory embedding cache with TTL
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ai-issue-intelligence/11-CONTEXT.md
@.planning/phases/11-ai-issue-intelligence/11-RESEARCH.md
@.planning/phases/11-ai-issue-intelligence/11-01-SUMMARY.md
@src/services/ai/BacklogPrioritizer.ts (AI service pattern with fallback)
@src/infrastructure/cache/ResourceCache.ts (caching pattern)
@src/domain/issue-intelligence-types.ts (types from 11-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbeddingCache.ts</name>
  <files>src/cache/EmbeddingCache.ts</files>
  <action>
Create a cache for storing issue embeddings to avoid recomputation. Follow the ResourceCache pattern for TTL-based caching.

**File header:**
```typescript
/**
 * Embedding Cache for Issue Intelligence
 *
 * In-memory cache for issue embeddings with TTL-based expiration.
 * Caches embeddings by issue ID with content hash validation to detect changes.
 * Supports optional file persistence.
 */

import * as crypto from 'crypto';
```

**Interface: CachedEmbedding**
```typescript
interface CachedEmbedding {
  issueId: string;
  contentHash: string;  // Hash of title + body to detect changes
  embedding: number[];
  cachedAt: number;     // Timestamp
}
```

**Class: EmbeddingCache**

Constructor:
- ttlMs: number = 24 * 60 * 60 * 1000 (24 hours default)
- maxSize: number = 10000 (default max entries)

Private fields:
- cache: Map<string, CachedEmbedding>
- ttlMs: number
- maxSize: number

**Method: get(issueId: string, contentHash: string): number[] | null**
- Check if issueId exists in cache
- Verify contentHash matches (content hasn't changed)
- Verify not expired (cachedAt + ttlMs > Date.now())
- Return embedding if valid, null otherwise
- Delete entry if expired or hash mismatch

**Method: set(issueId: string, contentHash: string, embedding: number[]): void**
- Evict oldest entries if cache exceeds maxSize
- Store new CachedEmbedding

**Method: static computeContentHash(title: string, body: string): string**
- Compute SHA256 hash of normalized (title + body)
- Return hex string

**Method: has(issueId: string): boolean**
- Check if issueId in cache (doesn't validate expiry)

**Method: clear(): void**
- Clear all cache entries

**Method: size(): number**
- Return current cache size

**Method: private evictOldest(): void**
- Find and delete entries with oldest cachedAt
- Delete up to 10% of maxSize to make room

Export class.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/cache/EmbeddingCache.ts`</verify>
  <done>EmbeddingCache with TTL, content hash validation, and LRU-style eviction</done>
</task>

<task type="auto">
  <name>Task 2: Create DuplicateDetectionService.ts</name>
  <files>src/services/ai/DuplicateDetectionService.ts</files>
  <action>
Create AI service for duplicate detection using embeddings. Follow BacklogPrioritizer pattern.

**File header:**
```typescript
/**
 * AI-Powered Duplicate Detection Service (AI-19)
 *
 * Detects duplicate issues using semantic similarity via embeddings.
 * Results are tiered by confidence:
 * - High (0.92+): Recommend auto-link as duplicate
 * - Medium (0.75-0.92): Flag for user review
 * - Low (<0.75): Don't surface
 */

import { embed, embedMany, cosineSimilarity } from 'ai';
import { openai } from '@ai-sdk/openai';
import { ConfidenceScorer } from './ConfidenceScorer.js';
import { EmbeddingCache } from '../../cache/EmbeddingCache.js';
import {
  DuplicateCandidate,
  DuplicateDetectionResult,
  DuplicateDetectionThresholds,
  IssueInput
} from '../../domain/issue-intelligence-types.js';
import { SectionConfidence } from '../../domain/ai-types.js';
```

**Default thresholds:**
```typescript
const DEFAULT_THRESHOLDS: DuplicateDetectionThresholds = {
  high: 0.92,
  medium: 0.75
};
```

**Class: DuplicateDetectionService**

Constructor:
- thresholds?: Partial<DuplicateDetectionThresholds>
- Initialize EmbeddingCache
- Initialize ConfidenceScorer
- Merge thresholds with defaults

Private fields:
- embeddingCache: EmbeddingCache
- confidenceScorer: ConfidenceScorer
- thresholds: DuplicateDetectionThresholds
- embeddingModel = openai.embeddingModel('text-embedding-3-small')

**Method: async detectDuplicates(params)**
Params: { issueTitle, issueDescription, existingIssues: IssueInput[], maxResults?: number }
Returns: Promise<DuplicateDetectionResult>

Implementation:
1. If existingIssues is empty, return empty result with high confidence
2. Prepare issue text: `${issueTitle}\n\n${issueDescription}`
3. Try to compute embeddings:
   a. Call embed() for new issue
   b. Get/compute embeddings for existing issues (use cache)
   c. Calculate cosineSimilarity for each pair
4. If embedding fails, call getFallbackDetection()
5. Sort by similarity descending
6. Tier results based on thresholds
7. Limit to maxResults (default 10)
8. Calculate confidence
9. Return DuplicateDetectionResult

**Method: private async getOrComputeEmbeddings(issues: IssueInput[]): Promise<Map<string, number[]>>**
- Check cache for each issue
- Batch compute embeddings for uncached issues using embedMany()
- Update cache for newly computed embeddings
- Return map of issueId -> embedding

**Method: private getFallbackDetection(params): DuplicateDetectionResult**
- Use keywordOverlapScore() for similarity
- Lower thresholds in fallback mode (high: 0.8, medium: 0.6)
- Set confidence low (40) with "Embeddings unavailable" reasoning

**Method: private keywordOverlapScore(text1: string, text2: string): number**
- Extract keywords (lowercase, remove stopwords)
- Calculate Jaccard similarity
- Return 0-1 score

**Method: private calculateConfidence(params, aiAvailable: boolean): SectionConfidence**
- Higher confidence when AI embeddings used
- Factor in number of issues scanned

Export class.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/services/ai/DuplicateDetectionService.ts`</verify>
  <done>DuplicateDetectionService with embedding-based similarity, tiered thresholds, caching, and fallback</done>
</task>

<task type="auto">
  <name>Task 3: Create RelatedIssueLinkingService.ts</name>
  <files>src/services/ai/RelatedIssueLinkingService.ts</files>
  <action>
Create AI service for finding related issues. Follow BacklogPrioritizer pattern.

**File header:**
```typescript
/**
 * AI-Powered Related Issue Linking Service (AI-20)
 *
 * Detects relationships between issues:
 * - Semantic: Similar topic/feature (via embeddings)
 * - Dependency: Blocks/blocked-by chains (via keyword analysis + AI)
 * - Component: Same area of codebase (via label/path analysis)
 */

import { embed, embedMany, cosineSimilarity } from 'ai';
import { generateObject } from 'ai';
import { z } from 'zod';
import { openai } from '@ai-sdk/openai';
import { AIServiceFactory } from './AIServiceFactory.js';
import { ConfidenceScorer } from './ConfidenceScorer.js';
import { EmbeddingCache } from '../../cache/EmbeddingCache.js';
import { RELATED_ISSUE_SYSTEM_PROMPT, formatRelatedIssuePrompt } from './prompts/IssueIntelligencePrompts.js';
import {
  IssueRelationship,
  RelatedIssueResult,
  RelatedIssueLinkingConfig,
  RelationshipType,
  DependencySubType,
  IssueInput
} from '../../domain/issue-intelligence-types.js';
import { SectionConfidence } from '../../domain/ai-types.js';
```

**Default config:**
```typescript
const DEFAULT_CONFIG: RelatedIssueLinkingConfig = {
  includeSemanticSimilarity: true,
  includeDependencies: true,
  includeComponentGrouping: true
};
```

**Dependency keywords:**
```typescript
const BLOCKING_KEYWORDS = ['prerequisite', 'requires', 'depends on', 'needs', 'blocked by', 'waiting for'];
const BLOCKS_KEYWORDS = ['enables', 'unblocks', 'required for', 'blocks', 'prerequisite for'];
```

**Class: RelatedIssueLinkingService**

Constructor:
- config?: Partial<RelatedIssueLinkingConfig>
- Initialize AIServiceFactory, EmbeddingCache, ConfidenceScorer
- Merge config with defaults

**Method: async findRelatedIssues(params)**
Params: { issueId, issueTitle, issueDescription, issueLabels?: string[], repositoryIssues: IssueInput[] }
Returns: Promise<RelatedIssueResult>

Implementation:
1. Filter out the source issue from repositoryIssues
2. Collect relationships from enabled methods:
   - If includeSemanticSimilarity: call findSemanticRelations()
   - If includeDependencies: call detectDependencies()
   - If includeComponentGrouping: call detectComponentGrouping()
3. Combine and deduplicate relationships (keep highest confidence)
4. Sort by confidence descending
5. Calculate overall confidence
6. Return RelatedIssueResult

**Method: private async findSemanticRelations(params): Promise<IssueRelationship[]>**
- Use embeddings to find semantically similar issues
- Threshold: 0.75 for semantic similarity
- Return IssueRelationship with type: 'semantic'

**Method: private async detectDependencies(params): Promise<IssueRelationship[]>**
- First pass: keyword detection (BLOCKING_KEYWORDS, BLOCKS_KEYWORDS)
- Second pass: AI analysis for implicit dependencies (if model available)
- Return IssueRelationship with type: 'dependency', subType: 'blocks' | 'blocked_by' | 'related_to'

**Method: private detectComponentGrouping(params): IssueRelationship[]**
- Compare issueLabels with other issues' labels
- Calculate label overlap score
- Group issues with same component/area labels
- Return IssueRelationship with type: 'component'

**Method: private async aiDependencyAnalysis(sourceIssue, candidateIssues): Promise<IssueRelationship[]>**
- Get AI model from factory
- If no model, return empty array
- Use generateObject with dependency analysis schema
- Return detected dependencies

**Method: private calculateLabelOverlap(labels1: string[], labels2: string[]): number**
- Jaccard similarity for label sets
- Return 0-1 score

Export class.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/services/ai/RelatedIssueLinkingService.ts`</verify>
  <done>RelatedIssueLinkingService with semantic/dependency/component detection and configurable options</done>
</task>

</tasks>

<verification>
Run after all tasks complete:
```bash
# TypeScript compilation
npx tsc --noEmit

# Verify service structure
grep "class DuplicateDetectionService" src/services/ai/DuplicateDetectionService.ts
grep "class RelatedIssueLinkingService" src/services/ai/RelatedIssueLinkingService.ts
grep "class EmbeddingCache" src/cache/EmbeddingCache.ts

# Verify embedding imports
grep "import.*embed.*cosineSimilarity.*from.*ai" src/services/ai/DuplicateDetectionService.ts
grep "import.*embed.*from.*ai" src/services/ai/RelatedIssueLinkingService.ts

# Verify cache usage
grep "EmbeddingCache" src/services/ai/DuplicateDetectionService.ts
grep "EmbeddingCache" src/services/ai/RelatedIssueLinkingService.ts

# Verify fallback methods
grep "getFallbackDetection" src/services/ai/DuplicateDetectionService.ts
```
</verification>

<success_criteria>
- [ ] TypeScript compilation passes with 0 errors
- [ ] DuplicateDetectionService uses embed/embedMany/cosineSimilarity from 'ai'
- [ ] DuplicateDetectionService has tiered thresholds (high: 0.92, medium: 0.75)
- [ ] RelatedIssueLinkingService detects three relationship types
- [ ] EmbeddingCache provides TTL-based caching with content hash validation
- [ ] Both services have fallback to keyword matching
</success_criteria>

<output>
After completion, create `.planning/phases/11-ai-issue-intelligence/11-03-SUMMARY.md`
</output>
