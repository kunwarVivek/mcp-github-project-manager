---
phase: 05-resilience-observability
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/infrastructure/health/HealthService.ts
  - src/infrastructure/health/index.ts
  - src/infrastructure/tools/health-tools.ts
  - src/infrastructure/tools/ToolRegistry.ts
  - src/services/ai/AIServiceFactory.ts
autonomous: true

must_haves:
  truths:
    - "Health check returns status of GitHub, AI, and cache services"
    - "health_check MCP tool is available and returns structured health data"
    - "AI service failures return graceful degradation responses"
    - "Circuit breaker state is visible in health check"
  artifacts:
    - path: "src/infrastructure/health/HealthService.ts"
      provides: "Centralized health check logic"
      exports: ["HealthService", "HealthStatus"]
    - path: "src/infrastructure/tools/health-tools.ts"
      provides: "health_check MCP tool"
      exports: ["healthCheckTool"]
  key_links:
    - from: "src/infrastructure/health/HealthService.ts"
      to: "src/services/ai/AIServiceFactory.ts"
      via: "checks AI availability"
      pattern: "isAIAvailable|validateConfiguration"
    - from: "src/infrastructure/health/HealthService.ts"
      to: "src/infrastructure/resilience/AIResiliencePolicy.ts"
      via: "gets circuit breaker state"
      pattern: "getCircuitState"
    - from: "src/infrastructure/tools/health-tools.ts"
      to: "src/infrastructure/health/HealthService.ts"
      via: "delegates to HealthService"
      pattern: "HealthService"
---

<objective>
Create health check infrastructure and graceful degradation for AI services.

Purpose: Operators need visibility into system health. AI failures should not crash the system but return partial/degraded results. This plan creates the HealthService, health_check MCP tool, and integrates graceful degradation.

Output:
- HealthService with comprehensive health checks
- health_check MCP tool
- Graceful degradation in AI service wrappers
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resilience-observability/05-RESEARCH.md
@.planning/phases/05-resilience-observability/05-01-SUMMARY.md
@.planning/phases/05-resilience-observability/05-02-SUMMARY.md

# Dependencies from prior plans
@src/infrastructure/resilience/AIResiliencePolicy.ts
@src/infrastructure/cache/ResourceCache.ts
@src/services/ai/AIServiceFactory.ts
@src/infrastructure/tools/ToolRegistry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HealthService with comprehensive checks</name>
  <files>
    src/infrastructure/health/HealthService.ts
    src/infrastructure/health/index.ts
  </files>
  <action>
1. Create `src/infrastructure/health/HealthService.ts`:
   - Import AIServiceFactory from '../../services/ai/AIServiceFactory'
   - Import ResourceCache from '../cache/ResourceCache'
   - Import AIResiliencePolicy from '../resilience/AIResiliencePolicy'

   - Define HealthStatus interface:
     ```typescript
     export interface HealthStatus {
       status: 'healthy' | 'degraded' | 'unhealthy';
       timestamp: string;
       uptime: number;
       services: {
         github: {
           connected: boolean;
           rateLimit?: { remaining: number; limit: number };
         };
         ai: {
           available: boolean;
           circuitState: 'closed' | 'open' | 'half-open';
           models: {
             available: string[];
             unavailable: string[];
           };
         };
         cache: {
           entries: number;
           persistenceEnabled: boolean;
           lastPersist?: string;
         };
       };
     }
     ```

   - Create HealthService class:
     - Constructor accepts optional dependencies:
       - aiFactory?: AIServiceFactory
       - aiResilience?: AIResiliencePolicy
       - cache?: ResourceCache

     - async check(): Promise<HealthStatus>
       - Gets uptime from process.uptime()
       - Checks each service:
         - GitHub: Try a lightweight API call if factory available, else assume connected
         - AI: Use aiFactory.isAIAvailable() and aiFactory.validateConfiguration()
         - Cache: Use cache.getStats()
       - Determines overall status:
         - 'unhealthy' if GitHub not connected
         - 'degraded' if AI unavailable or circuit open
         - 'healthy' otherwise

     - Private async checkGitHub(): Promise<{connected: boolean; rateLimit?: {...}}>
       - For now, return { connected: true } as placeholder
       - TODO: Wire to actual GitHub rate limit check in future

2. Create `src/infrastructure/health/index.ts`:
   - Export HealthService, HealthStatus

Note: GitHub check is a placeholder. Full implementation requires wiring GitHubRepositoryFactory which is out of scope for this plan. The structure is in place for future enhancement.
  </action>
  <verify>
npm run build completes without errors
grep "HealthStatus\|HealthService" src/infrastructure/health/ shows exports
  </verify>
  <done>
HealthService.check() returns HealthStatus with github, ai, cache service info.
Overall status computed from component health.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create health_check MCP tool</name>
  <files>
    src/infrastructure/tools/health-tools.ts
    src/infrastructure/tools/ToolRegistry.ts
  </files>
  <action>
1. Create `src/infrastructure/tools/health-tools.ts`:
   - Import z from 'zod'
   - Import ToolDefinition from './ToolRegistry' (or appropriate type)
   - Import HealthService, HealthStatus from '../health'
   - Import AIServiceFactory from '../../services/ai/AIServiceFactory'
   - Import ResourceCache from '../cache/ResourceCache'

   - Define healthStatusSchema using Zod:
     ```typescript
     const healthStatusSchema = z.object({
       status: z.enum(['healthy', 'degraded', 'unhealthy']),
       timestamp: z.string(),
       uptime: z.number(),
       services: z.object({
         github: z.object({
           connected: z.boolean(),
           rateLimit: z.object({
             remaining: z.number(),
             limit: z.number()
           }).optional()
         }),
         ai: z.object({
           available: z.boolean(),
           circuitState: z.enum(['closed', 'open', 'half-open']),
           models: z.object({
             available: z.array(z.string()),
             unavailable: z.array(z.string())
           })
         }),
         cache: z.object({
           entries: z.number(),
           persistenceEnabled: z.boolean(),
           lastPersist: z.string().optional()
         })
       })
     });
     ```

   - Create healthCheckTool: ToolDefinition:
     - name: 'health_check'
     - description: 'Check system health and service availability. Returns status of GitHub connection, AI services, and cache.'
     - inputSchema: z.object({}) (no input required)
     - outputSchema: healthStatusSchema
     - annotations: { behavior: 'read-only', audience: ['operator'] }
     - execute: async () => {
         const healthService = new HealthService({
           aiFactory: AIServiceFactory.getInstance(),
           cache: ResourceCache.getInstance()
         });
         return healthService.check();
       }

   - Export healthCheckTool

2. Modify `src/infrastructure/tools/ToolRegistry.ts`:
   - Import healthCheckTool from './health-tools'
   - Add healthCheckTool to the tool registration

Follow existing tool registration pattern in ToolRegistry.
  </action>
  <verify>
npm run build completes without errors
grep "health_check" src/infrastructure/tools/ shows tool definition
npm test passes
  </verify>
  <done>
health_check MCP tool registered and executable.
Returns structured HealthStatus response.
Tool has read-only annotation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add graceful degradation wrapper for AI services</name>
  <files>
    src/services/ai/AIServiceFactory.ts
  </files>
  <action>
1. Modify `src/services/ai/AIServiceFactory.ts`:
   - Import AIResiliencePolicy from '../../infrastructure/resilience/AIResiliencePolicy'

   - Add private field:
     ```typescript
     private resiliencePolicy?: AIResiliencePolicy;
     ```

   - Add method enableResilience(policy?: AIResiliencePolicy): void
     - Sets this.resiliencePolicy = policy ?? new AIResiliencePolicy()
     - Logs to stderr that resilience is enabled

   - Add method getResiliencePolicy(): AIResiliencePolicy | undefined
     - Returns this.resiliencePolicy

   - Add method isResilienceEnabled(): boolean
     - Returns this.resiliencePolicy !== undefined

   - Add method getCircuitState(): 'closed' | 'open' | 'half-open' | 'disabled'
     - If resilience disabled, return 'disabled'
     - Otherwise return resiliencePolicy.getCircuitState()

   - Add helper method for services to use:
     ```typescript
     async executeWithResilience<T>(
       operation: () => Promise<T>,
       fallback?: () => T
     ): Promise<T | { degraded: true; message: string }> {
       if (!this.resiliencePolicy) {
         // No resilience, execute directly
         return operation();
       }
       return this.resiliencePolicy.execute(operation, fallback);
     }
     ```

IMPORTANT: This is an opt-in enhancement. Existing behavior is unchanged.
Services that want resilience can call factory.executeWithResilience() instead of direct model calls.

2. Ensure validateConfiguration() includes circuit state:
   - Add circuitState to the return type if resilience is enabled
  </action>
  <verify>
npm run build completes without errors
grep "resiliencePolicy\|executeWithResilience" src/services/ai/AIServiceFactory.ts shows integration
npm test passes (no regressions)
  </verify>
  <done>
AIServiceFactory has enableResilience(), getCircuitState(), executeWithResilience() methods.
Resilience is opt-in (existing behavior unchanged).
Services can wrap AI calls with resilience policy.
  </done>
</task>

</tasks>

<verification>
All tasks verified by:
1. `npm run build` passes
2. `npm test` passes (no regressions)
3. health_check tool appears in MCP tool list
4. HealthService.check() returns structured HealthStatus
5. AIServiceFactory.executeWithResilience() handles failures gracefully
</verification>

<success_criteria>
- HealthService checks GitHub, AI, and cache status
- health_check MCP tool returns HealthStatus to clients
- Circuit breaker state visible in health check
- AIServiceFactory offers resilience-wrapped execution
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-resilience-observability/05-03-SUMMARY.md`
</output>
