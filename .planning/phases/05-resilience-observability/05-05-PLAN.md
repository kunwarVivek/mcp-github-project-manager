---
phase: 05-resilience-observability
plan: 05
type: execute
wave: 5
depends_on: ["05-04"]
files_modified:
  - tests/infrastructure/resilience/CircuitBreakerService.test.ts
  - tests/infrastructure/resilience/AIResiliencePolicy.test.ts
  - tests/infrastructure/observability/CorrelationContext.test.ts
  - tests/infrastructure/cache/CachePersistence.test.ts
  - tests/infrastructure/health/HealthService.test.ts
  - .planning/phases/05-resilience-observability/05-VERIFICATION.md
autonomous: true

must_haves:
  truths:
    - "All new infrastructure components have unit tests"
    - "Circuit breaker state transitions are tested"
    - "Correlation ID propagation is tested"
    - "Cache persistence save/restore is tested"
    - "Health check returns correct status"
    - "Phase 5 requirements verified complete"
  artifacts:
    - path: "tests/infrastructure/resilience/CircuitBreakerService.test.ts"
      provides: "Circuit breaker unit tests"
      min_lines: 50
    - path: "tests/infrastructure/health/HealthService.test.ts"
      provides: "Health service unit tests"
      min_lines: 50
    - path: ".planning/phases/05-resilience-observability/05-VERIFICATION.md"
      provides: "Phase verification report"
      contains: "PASS"
  key_links:
    - from: "tests/infrastructure/resilience/CircuitBreakerService.test.ts"
      to: "src/infrastructure/resilience/CircuitBreakerService.ts"
      via: "tests the circuit breaker"
      pattern: "CircuitBreakerService"
---

<objective>
Add unit tests for new infrastructure and verify Phase 5 completion.

Purpose: New resilience and observability components need test coverage. Phase 5 requirements must be verified complete before moving to Phase 6.

Output:
- Unit tests for CircuitBreakerService, AIResiliencePolicy, CorrelationContext, CachePersistence, HealthService
- Phase 5 verification report
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resilience-observability/05-RESEARCH.md
@.planning/phases/05-resilience-observability/05-04-SUMMARY.md

# Components to test
@src/infrastructure/resilience/CircuitBreakerService.ts
@src/infrastructure/resilience/AIResiliencePolicy.ts
@src/infrastructure/observability/CorrelationContext.ts
@src/infrastructure/cache/CachePersistence.ts
@src/infrastructure/health/HealthService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unit tests for resilience components</name>
  <files>
    tests/infrastructure/resilience/CircuitBreakerService.test.ts
    tests/infrastructure/resilience/AIResiliencePolicy.test.ts
  </files>
  <action>
1. Create tests/ directory structure if needed:
   - tests/infrastructure/resilience/

2. Create `tests/infrastructure/resilience/CircuitBreakerService.test.ts`:
   - Test circuit starts closed
   - Test circuit opens after consecutive failures
   - Test execute() returns result on success
   - Test execute() throws on failure
   - Test getState() returns correct state
   - Test isOpen() returns correct boolean

   ```typescript
   describe('CircuitBreakerService', () => {
     it('starts in closed state', () => {...});
     it('executes successfully when closed', async () => {...});
     it('opens after consecutive failures', async () => {...});
     it('returns isOpen() correctly', () => {...});
   });
   ```

3. Create `tests/infrastructure/resilience/AIResiliencePolicy.test.ts`:
   - Test execute() returns result on success
   - Test execute() retries on transient failure
   - Test execute() returns fallback when all retries fail
   - Test getCircuitState() returns state
   - Test DegradedResult is returned on circuit open

   ```typescript
   describe('AIResiliencePolicy', () => {
     it('executes successfully', async () => {...});
     it('retries on failure', async () => {...});
     it('returns fallback on exhausted retries', async () => {...});
     it('returns degraded result when circuit open', async () => {...});
   });
   ```

Use Jest mocks to simulate failures without hitting real services.
  </action>
  <verify>
npm test -- tests/infrastructure/resilience/ passes
grep -c "it\|test" tests/infrastructure/resilience/*.test.ts shows test count
  </verify>
  <done>
CircuitBreakerService has 4+ unit tests.
AIResiliencePolicy has 4+ unit tests.
All resilience tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for observability and cache</name>
  <files>
    tests/infrastructure/observability/CorrelationContext.test.ts
    tests/infrastructure/cache/CachePersistence.test.ts
  </files>
  <action>
1. Create `tests/infrastructure/observability/CorrelationContext.test.ts`:
   - Test startTrace() creates correlation ID
   - Test getCorrelationId() returns ID within trace
   - Test getCorrelationId() returns undefined outside trace
   - Test getTraceContext() returns full context
   - Test nested traces work correctly

   ```typescript
   describe('CorrelationContext', () => {
     it('generates correlation ID in startTrace', async () => {...});
     it('returns undefined outside trace', () => {...});
     it('returns context within trace', async () => {...});
     it('handles nested traces', async () => {...});
   });
   ```

2. Create `tests/infrastructure/cache/CachePersistence.test.ts`:
   - Test save() writes JSON file
   - Test restore() reads and parses JSON file
   - Test restore() filters expired entries
   - Test restore() returns empty map on missing file
   - Test exists() returns correct boolean
   - Test atomic write (temp file rename)

   ```typescript
   describe('CachePersistence', () => {
     let tempDir: string;

     beforeEach(() => {
       tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cache-test-'));
     });

     afterEach(() => {
       fs.rmSync(tempDir, { recursive: true });
     });

     it('saves cache to file', async () => {...});
     it('restores cache from file', async () => {...});
     it('filters expired entries on restore', async () => {...});
     it('returns empty map when file missing', async () => {...});
   });
   ```

Use temp directories for file-based tests.
  </action>
  <verify>
npm test -- tests/infrastructure/observability/ passes
npm test -- tests/infrastructure/cache/CachePersistence passes
  </verify>
  <done>
CorrelationContext has 4+ unit tests.
CachePersistence has 4+ unit tests.
All observability and cache tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add HealthService tests and create verification report</name>
  <files>
    tests/infrastructure/health/HealthService.test.ts
    .planning/phases/05-resilience-observability/05-VERIFICATION.md
  </files>
  <action>
1. Create `tests/infrastructure/health/HealthService.test.ts`:
   - Test check() returns HealthStatus structure
   - Test status is 'healthy' when all services ok
   - Test status is 'degraded' when AI unavailable
   - Test status is 'degraded' when circuit open
   - Test cache stats are included

   ```typescript
   describe('HealthService', () => {
     it('returns healthy status when all ok', async () => {...});
     it('returns degraded when AI unavailable', async () => {...});
     it('includes cache stats', async () => {...});
     it('includes AI configuration', async () => {...});
   });
   ```

2. Run full test suite: `npm test`

3. Create `.planning/phases/05-resilience-observability/05-VERIFICATION.md`:

```markdown
# Phase 5: Resilience and Observability - Verification Report

**Verified:** {date}
**Status:** COMPLETE

## Requirements Verification

| Requirement | Description | Status | Evidence |
|-------------|-------------|--------|----------|
| DEBT-21 | Circuit breaker for AI | PASS | CircuitBreakerService, AIResiliencePolicy |
| DEBT-22 | Health check endpoint | PASS | HealthService, health_check tool |
| DEBT-23 | Correlation ID tracing | PASS | CorrelationContext, TracingLogger |
| DEBT-24 | Cache persistence | PASS | CachePersistence, ResourceCache.enablePersistence() |
| DEBT-25 | Graceful degradation | PASS | AIResiliencePolicy fallback, DegradedResult |
| DEBT-26 | Update STATUS.md | PASS | STATUS.md updated |
| DEBT-27 | Document MCP tools | PASS | docs/TOOLS.md |
| DEBT-28 | API reference | PASS | docs/API.md |

## Success Criteria Verification

| Criterion | Status | Evidence |
|-----------|--------|----------|
| AI failures trigger circuit breaker | PASS | CircuitBreakerService opens after 5 failures |
| Health check returns service status | PASS | HealthService.check() returns HealthStatus |
| Correlation IDs in logs | PASS | TracingLogger includes correlationId |
| Cache survives restart | PASS | CachePersistence save/restore works |
| Partial results when AI unavailable | PASS | DegradedResult returned on fallback |

## Test Results

- npm test: XXX tests passing, 0 failing
- New tests added: ~20 for Phase 5 components
- Coverage maintained above 80%

## Phase Complete
```

Fill in test counts from actual npm test output.
  </action>
  <verify>
npm test passes with 0 failures
test -f .planning/phases/05-resilience-observability/05-VERIFICATION.md
grep "PASS" .planning/phases/05-resilience-observability/05-VERIFICATION.md shows all requirements passing
  </verify>
  <done>
HealthService has 4+ unit tests.
All Phase 5 tests pass.
05-VERIFICATION.md documents phase completion.
All 8 requirements verified.
  </done>
</task>

</tasks>

<verification>
All tasks verified by:
1. `npm test` passes with 0 failures
2. New test files exist in tests/infrastructure/
3. 05-VERIFICATION.md shows all requirements PASS
4. Test count increased by ~20 from Phase 4 baseline
</verification>

<success_criteria>
- CircuitBreakerService, AIResiliencePolicy, CorrelationContext, CachePersistence, HealthService all have unit tests
- All tests pass (0 failures)
- Phase 5 verification report shows all 8 requirements complete
- Coverage maintained above 80%
</success_criteria>

<output>
After completion, create `.planning/phases/05-resilience-observability/05-05-SUMMARY.md`
</output>
