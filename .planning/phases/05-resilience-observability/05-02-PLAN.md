---
phase: 05-resilience-observability
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/infrastructure/resilience/AIResiliencePolicy.ts
  - src/infrastructure/resilience/index.ts
  - src/infrastructure/observability/TracingLogger.ts
  - src/infrastructure/observability/index.ts
  - src/infrastructure/cache/ResourceCache.ts
autonomous: true

must_haves:
  truths:
    - "AI calls are wrapped with retry, circuit breaker, timeout, and fallback policies"
    - "Logger includes correlation ID in every log entry"
    - "Cache can be persisted to disk and restored on startup"
  artifacts:
    - path: "src/infrastructure/resilience/AIResiliencePolicy.ts"
      provides: "Composed resilience policy for AI service calls"
      exports: ["AIResiliencePolicy", "createAIResiliencePolicy"]
    - path: "src/infrastructure/observability/TracingLogger.ts"
      provides: "Logger that includes correlation ID in output"
      exports: ["TracingLogger", "createTracingLogger"]
    - path: "src/infrastructure/cache/ResourceCache.ts"
      provides: "Cache with persistence integration"
      exports: ["ResourceCache"]
  key_links:
    - from: "src/infrastructure/resilience/AIResiliencePolicy.ts"
      to: "src/infrastructure/resilience/CircuitBreakerService.ts"
      via: "uses circuit breaker for AI calls"
      pattern: "CircuitBreakerService"
    - from: "src/infrastructure/observability/TracingLogger.ts"
      to: "src/infrastructure/observability/CorrelationContext.ts"
      via: "gets correlation ID for log entries"
      pattern: "getCorrelationId"
    - from: "src/infrastructure/cache/ResourceCache.ts"
      to: "src/infrastructure/cache/CachePersistence.ts"
      via: "delegates persistence to CachePersistence"
      pattern: "CachePersistence"
---

<objective>
Integrate resilience, observability, and persistence into usable services.

Purpose: Build on the infrastructure from 05-01 to create services that will be used by the rest of the system. AIResiliencePolicy wraps AI calls, TracingLogger adds correlation IDs to logs, and ResourceCache gets persistence capability.

Output:
- AIResiliencePolicy with retry + circuit breaker + timeout + fallback
- TracingLogger that includes correlation IDs
- ResourceCache with persistence hooks
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resilience-observability/05-RESEARCH.md
@.planning/phases/05-resilience-observability/05-01-SUMMARY.md

# Infrastructure from 05-01
@src/infrastructure/resilience/CircuitBreakerService.ts
@src/infrastructure/observability/CorrelationContext.ts
@src/infrastructure/cache/CachePersistence.ts
@src/infrastructure/cache/ResourceCache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AIResiliencePolicy with composed policies</name>
  <files>
    src/infrastructure/resilience/AIResiliencePolicy.ts
    src/infrastructure/resilience/index.ts
  </files>
  <action>
1. Create `src/infrastructure/resilience/AIResiliencePolicy.ts`:
   - Import from cockatiel: wrap, retry, timeout, fallback, handleAll, ExponentialBackoff
   - Import CircuitBreakerService from './CircuitBreakerService'

   - Define AIResilienceConfig interface:
     ```typescript
     interface AIResilienceConfig {
       maxRetries?: number;          // default: 3
       timeoutMs?: number;           // default: 30000
       halfOpenAfterMs?: number;     // default: 30000
       consecutiveFailures?: number; // default: 5
     }
     ```

   - Define DegradedResult interface:
     ```typescript
     interface DegradedResult {
       degraded: true;
       message: string;
     }
     ```

   - Create AIResiliencePolicy class:
     - Constructor accepts config: AIResilienceConfig (optional)
     - Creates internal CircuitBreakerService named 'AI'
     - Stores config with defaults

     - async execute<T>(operation: () => Promise<T>, fallbackFn?: () => T | DegradedResult): Promise<T | DegradedResult>
       - Create composed policy using wrap():
         - fallback(handleAll, () => fallbackFn?.() ?? { degraded: true, message: 'AI service unavailable' })
         - retry(handleAll, { maxAttempts: config.maxRetries, backoff: new ExponentialBackoff() })
         - circuit breaker via this.circuitBreaker.execute()
         - timeout(config.timeoutMs)
       - Execute the composed policy

     - getCircuitState(): 'closed' | 'open' | 'half-open'
       - Delegates to CircuitBreakerService.getState()

     - isCircuitOpen(): boolean
       - Returns getCircuitState() === 'open'

2. Export createAIResiliencePolicy(config?: AIResilienceConfig): AIResiliencePolicy

3. Update `src/infrastructure/resilience/index.ts`:
   - Add export for AIResiliencePolicy, createAIResiliencePolicy

IMPORTANT: The policy composition order matters per Cockatiel docs:
- Fallback is OUTER (catches everything)
- Retry is next
- Circuit breaker is next
- Timeout is INNER (closest to the actual call)
  </action>
  <verify>
npm run build completes without errors
grep "wrap\|retry\|fallback\|timeout" src/infrastructure/resilience/AIResiliencePolicy.ts shows cockatiel usage
  </verify>
  <done>
AIResiliencePolicy wraps AI calls with composed resilience policies.
createAIResiliencePolicy factory function exists.
Circuit state is queryable via getCircuitState().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TracingLogger with correlation ID integration</name>
  <files>
    src/infrastructure/observability/TracingLogger.ts
    src/infrastructure/observability/index.ts
  </files>
  <action>
1. Create `src/infrastructure/observability/TracingLogger.ts`:
   - Import getCorrelationId, getTraceContext from './CorrelationContext'
   - Import ILogger from '../logger'

   - Define LogEntry interface:
     ```typescript
     interface LogEntry {
       timestamp: string;
       level: string;
       correlationId: string;
       operation?: string;
       message: string;
       data?: unknown;
       durationMs?: number;
     }
     ```

   - Create TracingLogger class implementing ILogger:
     - Constructor accepts prefix?: string

     - Private formatEntry(level: string, message: string, ...args: unknown[]): string
       - Gets correlation ID from getCorrelationId() or 'no-trace'
       - Gets operation from getTraceContext()?.operation
       - Calculates durationMs if trace context exists
       - Returns JSON.stringify(logEntry)

     - debug(message: string, ...args: unknown[]): void
       - Writes formatted entry to stderr

     - info(message: string, ...args: unknown[]): void
     - warn(message: string, ...args: unknown[]): void
     - error(message: string, ...args: unknown[]): void

2. Export createTracingLogger(prefix?: string): TracingLogger

3. Update `src/infrastructure/observability/index.ts`:
   - Add export for TracingLogger, createTracingLogger

Log format (JSON per line):
```json
{"timestamp":"2026-01-31T12:00:00.000Z","level":"info","correlationId":"abc-123","operation":"generate_prd","message":"Starting PRD generation","durationMs":1234}
```
  </action>
  <verify>
npm run build completes without errors
grep "getCorrelationId" src/infrastructure/observability/TracingLogger.ts shows integration
  </verify>
  <done>
TracingLogger implements ILogger interface.
All log entries include correlationId field.
JSON format enables log parsing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate CachePersistence into ResourceCache</name>
  <files>
    src/infrastructure/cache/ResourceCache.ts
  </files>
  <action>
1. Modify `src/infrastructure/cache/ResourceCache.ts`:
   - Import CachePersistence from './CachePersistence'

   - Add private fields:
     ```typescript
     private persistence?: CachePersistence;
     private persistInterval?: NodeJS.Timeout;
     private readonly PERSIST_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes
     ```

   - Add enablePersistence(cacheDirectory?: string): void
     - Creates CachePersistence instance
     - Starts periodic save interval
     - Logs to stderr that persistence is enabled

   - Add disablePersistence(): void
     - Clears interval
     - Sets persistence to undefined

   - Add async persist(): Promise<void>
     - If persistence enabled, calls persistence.save(this.cache)
     - Logs success/failure to stderr

   - Add async restore(): Promise<number>
     - If persistence enabled, calls persistence.restore()
     - Merges restored entries into current cache (non-expired only)
     - Returns count of restored entries
     - Logs to stderr

   - Add getStats(): { size: number; persistenceEnabled: boolean; lastPersist?: string }
     - Returns cache size and persistence status

   - Modify clear():
     - If persistence enabled, also delete the cache file (optional - could keep for recovery)

   - In singleton getInstance():
     - Do NOT auto-enable persistence (leave opt-in)

IMPORTANT: Persistence is OPT-IN via enablePersistence() call. Don't break existing behavior.

2. Add shutdown hook support:
   - Add async shutdown(): Promise<void>
     - Clears persist interval
     - Does one final persist()
     - Logs shutdown complete
  </action>
  <verify>
npm run build completes without errors
grep "persistence\|enablePersistence\|persist\(\)" src/infrastructure/cache/ResourceCache.ts shows integration
npm test passes (existing cache tests should still pass)
  </verify>
  <done>
ResourceCache has enablePersistence(), persist(), restore(), shutdown() methods.
Persistence is opt-in (existing behavior unchanged).
Periodic persistence every 5 minutes when enabled.
  </done>
</task>

</tasks>

<verification>
All tasks verified by:
1. `npm run build` passes
2. `npm test` passes (no regressions in cache tests)
3. AIResiliencePolicy can be instantiated and execute() works
4. TracingLogger outputs JSON with correlationId
5. ResourceCache.enablePersistence() enables file persistence
</verification>

<success_criteria>
- AIResiliencePolicy composes retry + circuit breaker + timeout + fallback
- TracingLogger includes correlationId in every log entry (JSON format)
- ResourceCache has opt-in persistence with periodic saves
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-resilience-observability/05-02-SUMMARY.md`
</output>
