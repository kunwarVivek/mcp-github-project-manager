---
phase: 05-resilience-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/infrastructure/resilience/CircuitBreakerService.ts
  - src/infrastructure/resilience/index.ts
  - src/infrastructure/observability/CorrelationContext.ts
  - src/infrastructure/observability/index.ts
  - src/infrastructure/cache/CachePersistence.ts
autonomous: true

must_haves:
  truths:
    - "Cockatiel library is installed and available"
    - "Circuit breaker can transition between closed, open, and half-open states"
    - "Correlation IDs can be generated and retrieved from async context"
    - "Cache entries can be saved to and loaded from disk"
  artifacts:
    - path: "src/infrastructure/resilience/CircuitBreakerService.ts"
      provides: "Circuit breaker wrapper using Cockatiel"
      exports: ["CircuitBreakerService"]
    - path: "src/infrastructure/observability/CorrelationContext.ts"
      provides: "AsyncLocalStorage-based correlation ID tracking"
      exports: ["startTrace", "getCorrelationId", "traceContext"]
    - path: "src/infrastructure/cache/CachePersistence.ts"
      provides: "JSON file-based cache persistence"
      exports: ["CachePersistence"]
  key_links:
    - from: "src/infrastructure/resilience/CircuitBreakerService.ts"
      to: "cockatiel"
      via: "import circuitBreaker, ConsecutiveBreaker"
      pattern: "import.*circuitBreaker.*from.*cockatiel"
    - from: "src/infrastructure/observability/CorrelationContext.ts"
      to: "node:async_hooks"
      via: "AsyncLocalStorage import"
      pattern: "AsyncLocalStorage"
---

<objective>
Create foundational resilience and observability infrastructure for Phase 5.

Purpose: Establish the building blocks that AI resilience, tracing, and health check features will use. These are standalone infrastructure components with no dependencies on existing services.

Output:
- CircuitBreakerService wrapping Cockatiel
- CorrelationContext for request tracing
- CachePersistence for cache survival across restarts
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resilience-observability/05-RESEARCH.md

# Existing infrastructure patterns
@src/infrastructure/cache/ResourceCache.ts
@src/infrastructure/logger/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Cockatiel and create CircuitBreakerService</name>
  <files>
    package.json
    src/infrastructure/resilience/CircuitBreakerService.ts
    src/infrastructure/resilience/index.ts
  </files>
  <action>
1. Install cockatiel: `npm install cockatiel`

2. Create `src/infrastructure/resilience/CircuitBreakerService.ts`:
   - Import from cockatiel: circuitBreaker, ConsecutiveBreaker, handleAll, CircuitState
   - Create CircuitBreakerService class:
     - Constructor accepts name (string) and optional config (halfOpenAfter: number, consecutiveFailures: number)
     - Default config: halfOpenAfter=30000ms, consecutiveFailures=5
     - Create circuit breaker with ConsecutiveBreaker(consecutiveFailures)
     - Track current state via onStateChange callback
     - Expose execute<T>(fn: () => Promise<T>): Promise<T>
     - Expose getState(): 'closed' | 'open' | 'half-open'
     - Expose isOpen(): boolean
   - Log state changes to stderr with [CircuitBreaker:{name}] prefix

3. Create `src/infrastructure/resilience/index.ts`:
   - Export CircuitBreakerService

Pattern from RESEARCH.md:
```typescript
this.circuitBreaker = circuitBreaker(handleAll, {
  halfOpenAfter: 30 * 1000,
  breaker: new ConsecutiveBreaker(5)
});
this.circuitBreaker.onStateChange(state => {
  process.stderr.write(`[CircuitBreaker:${this.name}] State: ${state}\n`);
});
```
  </action>
  <verify>
npm run build completes without errors
grep -r "circuitBreaker" src/infrastructure/resilience/ shows imports
  </verify>
  <done>
CircuitBreakerService exists with execute(), getState(), isOpen() methods.
Cockatiel appears in package.json dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CorrelationContext with AsyncLocalStorage</name>
  <files>
    src/infrastructure/observability/CorrelationContext.ts
    src/infrastructure/observability/index.ts
  </files>
  <action>
1. Create `src/infrastructure/observability/CorrelationContext.ts`:
   - Import AsyncLocalStorage from 'node:async_hooks'
   - Import v4 as uuidv4 from 'uuid' (already in deps)

   - Define TraceContext interface:
     ```typescript
     interface TraceContext {
       correlationId: string;
       startTime: number;
       operation: string;
     }
     ```

   - Create and export traceContext = new AsyncLocalStorage<TraceContext>()

   - Export startTrace<T>(operation: string, fn: () => Promise<T>): Promise<T>
     - Creates new TraceContext with uuidv4(), Date.now(), operation
     - Runs fn inside traceContext.run(context, fn)
     - Logs trace start and completion to stderr with JSON format

   - Export getCorrelationId(): string | undefined
     - Returns traceContext.getStore()?.correlationId

   - Export getTraceContext(): TraceContext | undefined
     - Returns traceContext.getStore()

2. Create `src/infrastructure/observability/index.ts`:
   - Export all from CorrelationContext

Pattern from RESEARCH.md:
```typescript
return traceContext.run(context, async () => {
  try {
    const result = await fn();
    logTraceComplete('success');
    return result;
  } catch (error) {
    logTraceComplete('error', error);
    throw error;
  }
});
```
  </action>
  <verify>
npm run build completes without errors
grep "AsyncLocalStorage" src/infrastructure/observability/ shows usage
  </verify>
  <done>
CorrelationContext exports startTrace, getCorrelationId, getTraceContext.
traceContext AsyncLocalStorage instance is exported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CachePersistence service</name>
  <files>
    src/infrastructure/cache/CachePersistence.ts
  </files>
  <action>
1. Create `src/infrastructure/cache/CachePersistence.ts`:
   - Import fs from 'node:fs/promises', path from 'node:path', existsSync from 'node:fs'

   - Define CacheSnapshot interface:
     ```typescript
     interface CacheSnapshot {
       version: 1;
       timestamp: string;
       entries: Array<{
         key: string;
         value: unknown;
         expiresAt?: number;
         tags?: string[];
       }>;
     }
     ```

   - Create CachePersistence class:
     - Constructor accepts cacheDirectory: string (default: '.cache')
     - filePath = path.join(cacheDirectory, 'cache-snapshot.json')
     - lastPersistTime: string | undefined

     - async save(entries: Map<string, CacheEntry<unknown>>): Promise<void>
       - Converts Map to CacheSnapshot format
       - Writes JSON to filePath using atomic write (write to .tmp, rename)
       - Updates lastPersistTime
       - Logs to stderr on success/failure

     - async restore(): Promise<Map<string, CacheEntry<unknown>>>
       - Reads and parses JSON from filePath
       - Filters out expired entries (expiresAt < Date.now())
       - Returns Map of valid entries
       - Returns empty Map on file not found or parse error

     - async exists(): Promise<boolean>
       - Returns existsSync(this.filePath)

     - getLastPersistTime(): string | undefined
       - Returns lastPersistTime

2. Match CacheEntry interface from ResourceCache.ts (import or redefine).

Pattern from RESEARCH.md - atomic write:
```typescript
const tempPath = `${this.filePath}.tmp`;
await fs.writeFile(tempPath, JSON.stringify(snapshot, null, 2), 'utf-8');
await fs.rename(tempPath, this.filePath);
```
  </action>
  <verify>
npm run build completes without errors
grep "CachePersistence" src/infrastructure/cache/ shows class export
  </verify>
  <done>
CachePersistence class exists with save(), restore(), exists(), getLastPersistTime() methods.
Uses atomic write pattern for reliability.
  </done>
</task>

</tasks>

<verification>
All tasks verified by:
1. `npm run build` passes
2. New directories exist: src/infrastructure/resilience/, src/infrastructure/observability/
3. Exports work: can import { CircuitBreakerService } from './infrastructure/resilience'
4. Exports work: can import { startTrace, getCorrelationId } from './infrastructure/observability'
5. Exports work: can import { CachePersistence } from './infrastructure/cache/CachePersistence'
</verification>

<success_criteria>
- Cockatiel ^3.2.1 in package.json
- CircuitBreakerService wraps Cockatiel circuit breaker with state tracking
- CorrelationContext provides AsyncLocalStorage-based tracing
- CachePersistence can serialize/deserialize cache to JSON file
- All three components build without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-resilience-observability/05-01-SUMMARY.md`
</output>
