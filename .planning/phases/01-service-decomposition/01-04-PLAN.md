---
phase: 01-service-decomposition
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/services/ProjectManagementService.ts
  - src/container.ts
  - src/index.ts
  - src/__tests__/unit/services/ProjectManagementService.test.ts
  - src/__tests__/integration/facade-wiring.test.ts
autonomous: true

must_haves:
  truths:
    - "ProjectManagementService delegates to extracted services"
    - "ProjectManagementService is under 500 lines"
    - "All existing tool handlers work unchanged"
    - "DI container wires all services correctly"
    - "All existing tests pass"
  artifacts:
    - path: "src/services/ProjectManagementService.ts"
      provides: "Facade coordinating extracted services"
      max_lines: 500
    - path: "src/container.ts"
      provides: "DI container registration for all services"
      exports: ["container"]
      contains: ["SubIssueService", "MilestoneService", "SprintPlanningService", "ProjectStatusService", "ProjectTemplateService", "ProjectLinkingService"]
    - path: "src/__tests__/integration/facade-wiring.test.ts"
      provides: "Integration tests for facade delegation"
      min_lines: 50
  key_links:
    - from: "src/services/ProjectManagementService.ts"
      to: "SubIssueService"
      via: "constructor injection and delegation"
      pattern: "this\\.subIssueService\\."
    - from: "src/services/ProjectManagementService.ts"
      to: "MilestoneService"
      via: "constructor injection and delegation"
      pattern: "this\\.milestoneService\\."
    - from: "src/container.ts"
      to: "src/services/*Service.ts"
      via: "container.register"
      pattern: "container\\.register"
---

<objective>
Refactor ProjectManagementService into a thin facade and wire all services via DI container.

Purpose: Transform the 3,291-line god class into a <500-line facade that delegates to the 6 extracted services. Create centralized DI container configuration. Verify all existing functionality works through the new structure.

Output: Refactored ProjectManagementService (facade), new container.ts, updated index.ts, and integration tests verifying the wiring works correctly.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-service-decomposition/01-RESEARCH.md
@.planning/phases/01-service-decomposition/01-01-SUMMARY.md
@.planning/phases/01-service-decomposition/01-02-SUMMARY.md
@.planning/phases/01-service-decomposition/01-03-SUMMARY.md
@src/services/ProjectManagementService.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DI Container Configuration</name>
  <files>
    src/container.ts
    src/index.ts
  </files>
  <action>
Create centralized DI container and integrate into server startup:

1. Create `src/container.ts`:
```typescript
import "reflect-metadata";
import { container } from "tsyringe";
import { GitHubRepositoryFactory } from "./infrastructure/github/GitHubRepositoryFactory";
import { SubIssueService } from "./services/SubIssueService";
import { MilestoneService } from "./services/MilestoneService";
import { SprintPlanningService } from "./services/SprintPlanningService";
import { ProjectStatusService } from "./services/ProjectStatusService";
import { ProjectTemplateService } from "./services/ProjectTemplateService";
import { ProjectLinkingService } from "./services/ProjectLinkingService";
import { ProjectManagementService } from "./services/ProjectManagementService";

export function configureContainer(token: string, owner: string, repo: string) {
  // Register factory instance
  const factory = new GitHubRepositoryFactory(token, owner, repo);
  container.registerInstance("GitHubRepositoryFactory", factory);

  // Register extracted services
  container.register("SubIssueService", { useClass: SubIssueService });
  container.register("MilestoneService", { useClass: MilestoneService });
  container.register("SprintPlanningService", { useClass: SprintPlanningService });
  container.register("ProjectStatusService", { useClass: ProjectStatusService });
  container.register("ProjectTemplateService", { useClass: ProjectTemplateService });
  container.register("ProjectLinkingService", { useClass: ProjectLinkingService });

  // Register facade
  container.register("ProjectManagementService", { useClass: ProjectManagementService });

  return container;
}

export { container };
```

2. Update `src/index.ts`:
   - Import `configureContainer` from `./container`
   - Call `configureContainer(token, owner, repo)` during server initialization
   - Resolve ProjectManagementService from container instead of direct instantiation
   - Keep backward compatibility: if DI fails, fall back to direct instantiation
  </action>
  <verify>
    - `npx tsc --noEmit` shows no type errors
    - Server starts without errors: `npm run build && node dist/index.js --help` (or check it compiles)
  </verify>
  <done>
    - src/container.ts exists with all 6 services + facade registered
    - src/index.ts uses container for service resolution
    - tsyringe DI works at runtime
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor ProjectManagementService to Facade</name>
  <files>
    src/services/ProjectManagementService.ts
  </files>
  <action>
Transform ProjectManagementService from god class to thin facade:

1. Update constructor to inject extracted services:
```typescript
@injectable()
export class ProjectManagementService {
  constructor(
    @inject("GitHubRepositoryFactory") private factory: GitHubRepositoryFactory,
    @inject("SubIssueService") private subIssueService: SubIssueService,
    @inject("MilestoneService") private milestoneService: MilestoneService,
    @inject("SprintPlanningService") private sprintPlanningService: SprintPlanningService,
    @inject("ProjectStatusService") private projectStatusService: ProjectStatusService,
    @inject("ProjectTemplateService") private templateService: ProjectTemplateService,
    @inject("ProjectLinkingService") private linkingService: ProjectLinkingService
  ) {}
```

2. Replace extracted method implementations with delegation:
```typescript
// SubIssue delegation
async updateIssueStatus(...args) { return this.subIssueService.updateIssueStatus(...args); }
async addIssueDependency(...args) { return this.subIssueService.addIssueDependency(...args); }
// ... etc for all 5 SubIssue methods

// Milestone delegation
async getMilestoneMetrics(...args) { return this.milestoneService.getMilestoneMetrics(...args); }
// ... etc for all 7 Milestone methods

// Sprint delegation
async planSprint(...args) { return this.sprintPlanningService.planSprint(...args); }
// ... etc for all Sprint methods

// ProjectStatus delegation
async createProject(...args) { return this.projectStatusService.createProject(...args); }
// ... etc for all 5 Project methods

// Template delegation
async getProjectReadme(...args) { return this.templateService.getProjectReadme(...args); }
// ... etc for all 8 Template methods

// Linking delegation
async addProjectItem(...args) { return this.linkingService.addProjectItem(...args); }
// ... etc for all 5 Linking methods
```

3. KEEP in ProjectManagementService (coordination methods that span services):
   - `createRoadmap` - coordinates projects, milestones, and issues
   - `getRepositoryFactory` - returns factory for sync service
   - Any other methods that genuinely orchestrate across multiple domains

4. REMOVE from ProjectManagementService:
   - All method implementations that were extracted
   - Interfaces that were moved to extracted services (MilestoneMetrics, SprintMetrics)
   - The `mapErrorToMCPError` helper (each service has its own copy)
   - Zod schemas that moved to extracted services (PlanSprintSchema)

5. Re-export interfaces from extracted services for backward compatibility:
```typescript
export { MilestoneMetrics } from "./MilestoneService";
export { SprintMetrics } from "./SprintPlanningService";
```

TARGET: Under 500 lines. Count before/after with `wc -l`.
  </action>
  <verify>
    - `wc -l src/services/ProjectManagementService.ts` shows under 500 lines
    - `npx tsc --noEmit` shows no type errors
    - All delegated methods have correct signatures (TypeScript verifies this)
  </verify>
  <done>
    - ProjectManagementService.ts is under 500 lines
    - All extracted methods delegate to injected services
    - Coordination methods (createRoadmap) remain with implementation
    - Re-exports maintain backward compatibility
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Tests and Verify Integration</name>
  <files>
    src/__tests__/unit/services/ProjectManagementService.test.ts
    src/__tests__/integration/facade-wiring.test.ts
  </files>
  <action>
Update existing tests and add integration tests for facade wiring:

1. Update `src/__tests__/unit/services/ProjectManagementService.test.ts`:
   - Update imports to use container-based setup
   - Mock injected services instead of repositories for delegated methods
   - Keep tests for coordination methods (createRoadmap) that test actual implementation
   - Remove tests for methods that are now tested in extracted service test files
   - Verify facade delegation works correctly

2. Create `src/__tests__/integration/facade-wiring.test.ts`:
```typescript
import { configureContainer, container } from '../../container';
import { ProjectManagementService } from '../../services/ProjectManagementService';
import { MilestoneService } from '../../services/MilestoneService';
// ... other imports

describe('Facade Wiring Integration', () => {
  beforeEach(() => {
    container.clearInstances();
    // Configure with test credentials
    configureContainer('test-token', 'test-owner', 'test-repo');
  });

  it('should resolve ProjectManagementService from container', () => {
    const service = container.resolve(ProjectManagementService);
    expect(service).toBeDefined();
  });

  it('should resolve all extracted services', () => {
    expect(container.resolve("MilestoneService")).toBeDefined();
    expect(container.resolve("SubIssueService")).toBeDefined();
    expect(container.resolve("SprintPlanningService")).toBeDefined();
    expect(container.resolve("ProjectStatusService")).toBeDefined();
    expect(container.resolve("ProjectTemplateService")).toBeDefined();
    expect(container.resolve("ProjectLinkingService")).toBeDefined();
  });

  it('should delegate getMilestoneMetrics to MilestoneService', async () => {
    const facade = container.resolve(ProjectManagementService);
    const milestoneService = container.resolve<MilestoneService>("MilestoneService");

    // Spy on the underlying service
    const spy = jest.spyOn(milestoneService, 'getMilestoneMetrics');

    // Call through facade
    try {
      await facade.getMilestoneMetrics('test-id');
    } catch (e) {
      // Expected to fail without real GitHub - we just verify delegation
    }

    expect(spy).toHaveBeenCalledWith('test-id', false);
  });

  // Add similar delegation tests for other services
});
```

3. Run full test suite:
   - `npm test` - all existing tests should pass
   - Verify no regressions from the refactoring
  </action>
  <verify>
    - `npm test` passes with no failures related to refactoring
    - Integration tests verify DI wiring works
    - `npm test -- --testPathPattern="ProjectManagementService|facade-wiring"` passes
  </verify>
  <done>
    - ProjectManagementService.test.ts updated for facade pattern
    - facade-wiring.test.ts verifies DI integration
    - All existing tests pass
    - No circular dependency errors at runtime
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `wc -l src/services/ProjectManagementService.ts` - Under 500 lines
2. `npx tsc --noEmit` - No TypeScript errors
3. `npm test` - All tests pass (existing + new integration tests)
4. `npm run build` - Builds successfully
5. No circular dependencies (check with `madge --circular src/`)
6. DI container resolves all services correctly
</verification>

<success_criteria>
1. ProjectManagementService.ts is under 500 lines (DEBT-07 complete)
2. All 6 extracted services wired via DI container
3. src/container.ts provides centralized DI configuration
4. All existing tests pass (no regressions)
5. New integration tests verify facade wiring
6. Server starts and resolves services correctly
7. No circular dependencies between services
8. Backward compatibility maintained (external API unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-decomposition/01-04-SUMMARY.md`
</output>
