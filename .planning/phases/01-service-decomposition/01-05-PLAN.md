---
phase: 01-service-decomposition
plan: 05
type: execute
wave: 1
depends_on: ["01-04"]
files_modified:
  - src/__tests__/unit/services/ProjectManagementService.test.ts
  - tests/ai-services/RoadmapPlanningService.test.ts
  - tests/ai-services/IssueEnrichmentService.test.ts
  - tests/ai-services/IssueTriagingService.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All 16 unit tests in ProjectManagementService.test.ts pass"
    - "All 4 AI service test files compile without errors"
    - "npm test runs with no test failures introduced by DI refactoring"
  artifacts:
    - path: "src/__tests__/unit/services/ProjectManagementService.test.ts"
      provides: "Fixed unit tests with proper mock setup for DI architecture"
    - path: "tests/ai-services/RoadmapPlanningService.test.ts"
      provides: "Updated to use createProjectManagementService()"
    - path: "tests/ai-services/IssueEnrichmentService.test.ts"
      provides: "Updated to use createProjectManagementService()"
    - path: "tests/ai-services/IssueTriagingService.test.ts"
      provides: "Updated to use createProjectManagementService()"
  key_links:
    - from: "tests/ai-services/*.test.ts"
      to: "src/container.ts"
      via: "import createProjectManagementService"
      pattern: "createProjectManagementService"
---

<objective>
Fix test regressions introduced by the DI refactoring in Plan 04.

Purpose: The facade pattern and DI container changes broke 16 unit tests and made 4 test files fail to compile. Tests must pass for Phase 1 to be considered complete.

Output: All modified test files compile and pass. No regressions in test suite.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-service-decomposition/01-04-SUMMARY.md
@.planning/phases/01-service-decomposition/01-VERIFICATION.md
@src/container.ts
@src/services/ProjectManagementService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix ProjectManagementService.test.ts mock setup</name>
  <files>
    src/__tests__/unit/services/ProjectManagementService.test.ts
  </files>
  <action>
The current test file has a mock setup problem: it creates the service using `createProjectManagementService()`, then tries to mock the factory methods after instantiation. By that point, the service has already stored references to the original (unmocked) factory.

Fix the mock setup using one of two approaches:

**Approach A (Preferred): Mock at module level before import**
```typescript
// At top of file, before createProjectManagementService is used
jest.mock('../../../infrastructure/github/GitHubRepositoryFactory');

// In beforeEach, configure the mock implementation
const mockFactory = {
  graphql: jest.fn(),
  createProjectRepository: jest.fn(),
  // ... etc
};
(GitHubRepositoryFactory as jest.Mock).mockImplementation(() => mockFactory);
```

**Approach B: Create service manually with pre-mocked factory**
```typescript
// Create mock factory first
const mockFactory = {
  graphql: jest.fn(),
  // ... etc
} as unknown as GitHubRepositoryFactory;

// Create mock extracted services (stubs - not called by setFieldValue/getFieldValue)
const mockSubIssue = {} as SubIssueService;
const mockMilestone = {} as MilestoneService;
// ... etc

// Instantiate service directly with mocks
service = new ProjectManagementService(
  mockFactory,
  mockSubIssue,
  mockMilestone,
  mockSprint,
  mockProjectStatus,
  mockTemplate,
  mockLinking
);
```

The tests are for `setFieldValue` and `getFieldValue` which use `this.factory.graphql()` directly (not delegated to extracted services). So the fix needs to ensure `mockGraphql` is properly intercepted.

**Key changes:**
1. Remove `createProjectManagementService()` call
2. Create mocked factory with `graphql` method BEFORE service instantiation
3. Create stub/empty mocks for the 6 extracted services (they're not used by setFieldValue/getFieldValue)
4. Instantiate `ProjectManagementService` directly with the mocks
5. Store `mockGraphql` reference for test assertions
6. Remove the `Object.defineProperty` hacks that try to mock after construction

The repository mocks (`projectRepo`, `milestoneRepo`, `issueRepo`) can be removed if not needed for these specific tests.

Verify: All 16 tests in `setFieldValue` and `getFieldValue` describe blocks pass.
  </action>
  <verify>
    - `npx tsc --noEmit` shows no type errors in ProjectManagementService.test.ts
    - `npm test -- --testPathPattern="ProjectManagementService.test" --no-coverage` runs with 0 failures
  </verify>
  <done>
    - Mock setup creates factory with graphql mock BEFORE service instantiation
    - All 16 setFieldValue/getFieldValue tests pass
    - No Object.defineProperty hacks remain in beforeEach
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix AI service test files to use createProjectManagementService</name>
  <files>
    tests/ai-services/RoadmapPlanningService.test.ts
    tests/ai-services/IssueEnrichmentService.test.ts
    tests/ai-services/IssueTriagingService.test.ts
  </files>
  <action>
All three test files have the same issue: they use the old 3-argument constructor pattern:

```typescript
// Current (broken)
new ProjectManagementService('test-owner', 'test-repo', 'test-token')
```

This no longer works because the constructor now takes 7 arguments (factory + 6 services).

**Fix for all three files:**

1. Add import for `createProjectManagementService`:
```typescript
import { createProjectManagementService } from '../../src/container';
```

2. Keep the `jest.mock('../../src/services/ProjectManagementService')` - this mocks the module so the actual constructor isn't called.

3. In `beforeEach`, the mock implementation returns `mockProjectService`:
```typescript
(ProjectManagementService as jest.Mock).mockImplementation(() => mockProjectService);
```

4. When instantiating in service constructor, there are two options:

**Option A: Use createProjectManagementService (if mock intercepts properly)**
Since `jest.mock('../../src/services/ProjectManagementService')` mocks the class, and `createProjectManagementService` internally calls `new ProjectManagementService(...)`, the mock should intercept. But verify this works.

**Option B: Keep using mocked constructor directly**
The current pattern of `new ProjectManagementService('test-owner', 'test-repo', 'test-token')` will work if the mock intercepts constructor calls. The mock doesn't care about argument count - it returns `mockProjectService` regardless.

Actually, re-reading the code: the jest.mock at module level should make the constructor call work regardless of argument count. The compile error might be TypeScript type checking, not runtime.

**The real fix:** Since these files use `jest.mock('../../src/services/ProjectManagementService')`, the constructor is mocked and arguments don't matter at runtime. The issue is TypeScript type checking.

**Solution:** Cast to avoid TypeScript error:
```typescript
// Change this:
new ProjectManagementService('test-owner', 'test-repo', 'test-token')

// To this:
(ProjectManagementService as any)('test-owner', 'test-repo', 'test-token')

// Or use createProjectManagementService which has the 3-arg signature:
createProjectManagementService('test-owner', 'test-repo', 'test-token')
```

The cleanest fix is to use `createProjectManagementService()` which is the backward-compatible helper designed for exactly this purpose:

```typescript
// In RoadmapPlanningService.test.ts
import { createProjectManagementService } from '../../src/container';

// In beforeEach or test
service = new RoadmapPlanningService(
  AIServiceFactory.getInstance(),
  createProjectManagementService('test-owner', 'test-repo', 'test-token')
);
```

But wait - the services under test take a ProjectManagementService instance that they use. Since we're mocking ProjectManagementService at module level, we can either:
1. Keep the mock pattern and just fix the type issue
2. Use createProjectManagementService which creates a real instance (but the underlying graphql calls would need mocking)

Given these tests mock ProjectManagementService entirely (not the underlying graphql), keep the existing mock pattern but fix the TypeScript signature issue.

**Final fix for each file:**
Change:
```typescript
new ProjectManagementService('test-owner', 'test-repo', 'test-token')
```
To:
```typescript
(ProjectManagementService as jest.MockedClass<typeof ProjectManagementService>)
  .mock.results[0]?.value || mockProjectService
```

Or simpler - since mockImplementation returns mockProjectService anyway, just use mockProjectService directly:
```typescript
service = new RoadmapPlanningService(
  AIServiceFactory.getInstance(),
  mockProjectService as ProjectManagementService
);
```

This avoids the constructor call entirely while still providing the mock. Update all three files similarly.
  </action>
  <verify>
    - `npx tsc --noEmit` shows no type errors in tests/ai-services/*.test.ts
    - `npm test -- --testPathPattern="ai-services" --no-coverage` runs without compile errors
  </verify>
  <done>
    - RoadmapPlanningService.test.ts compiles and passes
    - IssueEnrichmentService.test.ts compiles and passes
    - IssueTriagingService.test.ts compiles and passes
    - No changes to actual service functionality
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. `npx tsc --noEmit` - No TypeScript errors in any test file
2. `npm test -- --testPathPattern="ProjectManagementService.test" --no-coverage` - All 16+ tests pass
3. `npm test -- --testPathPattern="ai-services" --no-coverage` - All AI service tests pass
4. `npm test` - Full test suite runs with no new failures
</verification>

<success_criteria>
1. ProjectManagementService.test.ts has proper mock setup (no Object.defineProperty hacks)
2. All 16 setFieldValue/getFieldValue tests pass
3. All AI service test files (RoadmapPlanningService, IssueEnrichmentService, IssueTriagingService) compile
4. npm test shows no failures from DI refactoring
5. Test approach documented in code comments for future maintainers
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-decomposition/01-05-SUMMARY.md`
</output>
