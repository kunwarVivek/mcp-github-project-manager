---
phase: 02-mcp-protocol-compliance
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/infrastructure/tools/ToolSchemas.ts
  - src/infrastructure/tools/schemas/project-schemas.ts
autonomous: true

must_haves:
  truths:
    - "All project tools have behavior annotations"
    - "All project tools have output schemas defined"
    - "Output schemas match actual TypeScript return types"
    - "Annotations correctly classify read-only vs mutating operations"
  artifacts:
    - path: "src/infrastructure/tools/schemas/project-schemas.ts"
      provides: "Output schema definitions for project tools"
      exports: ["ProjectOutputSchema", "ProjectListOutputSchema"]
  key_links:
    - from: "src/infrastructure/tools/ToolSchemas.ts"
      to: "src/infrastructure/tools/annotations/tool-annotations.ts"
      via: "import ANNOTATION_PATTERNS"
      pattern: "ANNOTATION_PATTERNS"
---

<objective>
Add annotations and output schemas to all project-related and planning tools.

Purpose: Enable clients to understand project tool behavior and expected output types.
Output: 20+ project tools with annotations and type-safe output schemas.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-protocol-compliance/02-RESEARCH.md
@.planning/phases/02-mcp-protocol-compliance/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project output schema definitions</name>
  <files>src/infrastructure/tools/schemas/project-schemas.ts</files>
  <action>
Create src/infrastructure/tools/schemas/project-schemas.ts with output schemas:

```typescript
import { z } from "zod";

// ===== Base Types =====

export const ProjectFieldSchema = z.object({
  id: z.string(),
  name: z.string(),
  dataType: z.string(),
  options: z.array(z.object({
    id: z.string(),
    name: z.string(),
  })).optional(),
});

export const ProjectViewSchema = z.object({
  id: z.string(),
  name: z.string(),
  layout: z.string(),
  filter: z.string().optional(),
  sortBy: z.array(z.object({
    field: z.string(),
    direction: z.enum(["asc", "desc"]),
  })).optional(),
});

export const ProjectItemSchema = z.object({
  id: z.string(),
  type: z.enum(["issue", "pull_request", "draft_issue"]),
  title: z.string(),
  state: z.string().optional(),
  fieldValues: z.record(z.string(), z.unknown()).optional(),
});

// ===== Project Tool Output Schemas =====

export const ProjectOutputSchema = z.object({
  id: z.string(),
  title: z.string(),
  shortDescription: z.string().optional(),
  visibility: z.enum(["private", "public"]),
  status: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  fields: z.array(ProjectFieldSchema).optional(),
  views: z.array(ProjectViewSchema).optional(),
});

export const ProjectListOutputSchema = z.object({
  projects: z.array(ProjectOutputSchema),
  totalCount: z.number(),
  hasMore: z.boolean().optional(),
});

export const ProjectReadmeOutputSchema = z.object({
  content: z.string(),
  updatedAt: z.string().optional(),
});

// ===== Field Value Schemas =====

export const FieldValueOutputSchema = z.object({
  fieldId: z.string(),
  fieldName: z.string(),
  value: z.unknown(),
  formattedValue: z.string().optional(),
});

// ===== Project Item Schemas =====

export const ProjectItemListOutputSchema = z.object({
  items: z.array(ProjectItemSchema),
  totalCount: z.number(),
  hasMore: z.boolean().optional(),
});

export const ProjectItemAddOutputSchema = z.object({
  itemId: z.string(),
  projectId: z.string(),
  contentId: z.string(),
  contentType: z.enum(["issue", "pull_request"]),
});

// ===== Milestone Schemas =====

export const MilestoneOutputSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional(),
  dueDate: z.string().optional(),
  state: z.enum(["open", "closed"]),
  progress: z.object({
    openIssues: z.number(),
    closedIssues: z.number(),
    completionPercentage: z.number(),
  }).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export const MilestoneListOutputSchema = z.object({
  milestones: z.array(MilestoneOutputSchema),
  totalCount: z.number(),
});

export const MilestoneMetricsOutputSchema = z.object({
  milestoneId: z.string(),
  title: z.string(),
  openIssues: z.number(),
  closedIssues: z.number(),
  completionPercentage: z.number(),
  dueDate: z.string().optional(),
  isOverdue: z.boolean(),
  daysRemaining: z.number().optional(),
  issues: z.array(z.object({
    id: z.string(),
    title: z.string(),
    state: z.string(),
  })).optional(),
});

// ===== Sprint Schemas =====

export const SprintOutputSchema = z.object({
  id: z.string(),
  title: z.string(),
  startDate: z.string(),
  endDate: z.string(),
  goals: z.array(z.string()).optional(),
  status: z.enum(["planned", "active", "completed"]).optional(),
  createdAt: z.string(),
});

export const SprintListOutputSchema = z.object({
  sprints: z.array(SprintOutputSchema),
  totalCount: z.number(),
});

export const SprintMetricsOutputSchema = z.object({
  sprintId: z.string(),
  title: z.string(),
  totalIssues: z.number(),
  completedIssues: z.number(),
  completionPercentage: z.number(),
  remainingDays: z.number(),
  velocity: z.number().optional(),
  issues: z.array(z.object({
    id: z.string(),
    title: z.string(),
    state: z.string(),
  })).optional(),
});

// ===== Roadmap Schemas =====

export const RoadmapOutputSchema = z.object({
  projectId: z.string(),
  projectTitle: z.string(),
  milestones: z.array(z.object({
    milestoneId: z.string(),
    title: z.string(),
    issuesCreated: z.number(),
  })),
  totalIssuesCreated: z.number(),
});

// ===== Generic Success Schemas =====

export const SuccessOutputSchema = z.object({
  success: z.boolean(),
  message: z.string().optional(),
});

export const DeleteOutputSchema = z.object({
  deleted: z.boolean(),
  id: z.string(),
  type: z.string(),
});
```

Create the schemas directory if it doesn't exist.
  </action>
  <verify>
```bash
ls src/infrastructure/tools/schemas/
npm run build
```
File exists and build passes.
  </verify>
  <done>Project output schemas defined covering all project tool return types</done>
</task>

<task type="auto">
  <name>Task 2: Add annotations to project tool definitions</name>
  <files>src/infrastructure/tools/ToolSchemas.ts</files>
  <action>
Update project-related tool definitions in ToolSchemas.ts to include annotations.

1. Add import at top of file:
```typescript
import { ANNOTATION_PATTERNS } from "./annotations/tool-annotations.js";
import {
  ProjectOutputSchema,
  ProjectListOutputSchema,
  ProjectReadmeOutputSchema,
  // ... other schemas as needed
} from "./schemas/project-schemas.js";
```

2. Update each project tool definition to include annotations and outputSchema. Examples:

```typescript
// Read-only tools
export const getProjectTool: ToolDefinition<GetProjectArgs, z.infer<typeof ProjectOutputSchema>> = {
  name: "get_project",
  title: "Get Project",
  description: "Get details of a specific GitHub project",
  schema: getProjectSchema,
  outputSchema: ProjectOutputSchema,
  annotations: ANNOTATION_PATTERNS.readOnly,
};

export const listProjectsTool: ToolDefinition<ListProjectsArgs, z.infer<typeof ProjectListOutputSchema>> = {
  name: "list_projects",
  title: "List Projects",
  description: "List GitHub projects for the authenticated user",
  schema: listProjectsSchema,
  outputSchema: ProjectListOutputSchema,
  annotations: ANNOTATION_PATTERNS.readOnly,
};

// Create tools
export const createProjectTool: ToolDefinition<CreateProjectArgs, z.infer<typeof ProjectOutputSchema>> = {
  name: "create_project",
  title: "Create Project",
  description: "Create a new GitHub project",
  schema: createProjectSchema,
  outputSchema: ProjectOutputSchema,
  annotations: ANNOTATION_PATTERNS.create,
};

// Update tools (idempotent - setting to specific state)
export const updateProjectTool: ToolDefinition<UpdateProjectArgs, z.infer<typeof ProjectOutputSchema>> = {
  name: "update_project",
  title: "Update Project",
  description: "Update a GitHub project's properties",
  schema: updateProjectSchema,
  outputSchema: ProjectOutputSchema,
  annotations: ANNOTATION_PATTERNS.updateIdempotent,
};

// Delete tools
export const deleteProjectTool: ToolDefinition<DeleteProjectArgs, z.infer<typeof DeleteOutputSchema>> = {
  name: "delete_project",
  title: "Delete Project",
  description: "Delete a GitHub project",
  schema: deleteProjectSchema,
  outputSchema: DeleteOutputSchema,
  annotations: ANNOTATION_PATTERNS.delete,
};
```

3. Apply annotations to ALL project-related tools:
   - get_project, list_projects: readOnly
   - get_project_readme, list_project_fields, list_project_views, list_project_items: readOnly
   - get_field_value: readOnly
   - create_project, create_milestone, create_project_field, create_project_view: create
   - update_project, update_milestone, update_project_field, update_project_view: updateIdempotent
   - set_field_value: updateIdempotent (same value = same result)
   - clear_field_value: updateIdempotent
   - add_project_item: create (or updateIdempotent if re-adding is no-op)
   - delete_project, delete_milestone, delete_project_view: delete
   - remove_project_item, archive_project_item: delete
   - unarchive_project_item: updateIdempotent
   - update_project_readme: updateIdempotent

4. Apply annotations to planning tools:
   - get_milestone_metrics, get_sprint_metrics, get_overdue_milestones, get_upcoming_milestones: readOnly
   - create_roadmap: create
   - plan_sprint: create
   - create_sprint, create_milestone: create
   - list_sprints, list_milestones, get_current_sprint: readOnly
   - update_sprint, update_milestone: updateIdempotent
   - add_issues_to_sprint: updateNonIdempotent (can add same issue again? If no-op, use updateIdempotent)
   - remove_issues_from_sprint: updateIdempotent
  </action>
  <verify>
```bash
npm run build
npm test
```
Build passes and existing tests work.
  </verify>
  <done>All project and planning tools have annotations and output schemas</done>
</task>

<task type="auto">
  <name>Task 3: Add annotations to label and field value tools</name>
  <files>src/infrastructure/tools/ToolSchemas.ts</files>
  <action>
Continue updating ToolSchemas.ts for remaining project-adjacent tools:

1. Label tools:
```typescript
export const createLabelTool: ToolDefinition<CreateLabelArgs, z.infer<typeof LabelOutputSchema>> = {
  name: "create_label",
  title: "Create Label",
  description: "Create a new label in the repository",
  schema: createLabelSchema,
  outputSchema: LabelOutputSchema,
  annotations: ANNOTATION_PATTERNS.create,
};

export const listLabelsTool: ToolDefinition<ListLabelsArgs, z.infer<typeof LabelListOutputSchema>> = {
  name: "list_labels",
  title: "List Labels",
  description: "List all labels in the repository",
  schema: listLabelsSchema,
  outputSchema: LabelListOutputSchema,
  annotations: ANNOTATION_PATTERNS.readOnly,
};
```

2. Add missing schema definitions to project-schemas.ts if needed:
```typescript
export const LabelOutputSchema = z.object({
  id: z.string(),
  name: z.string(),
  color: z.string(),
  description: z.string().optional(),
});

export const LabelListOutputSchema = z.object({
  labels: z.array(LabelOutputSchema),
  totalCount: z.number(),
});
```

3. Iteration tools (if any exist in the project tools category):
```typescript
// get_iteration_configuration, get_current_iteration, get_iteration_items, get_iteration_by_date: readOnly
// assign_items_to_iteration: updateIdempotent (assigning to same iteration = same result)
```

4. Verify all ~35 project/planning tools have annotations.
  </action>
  <verify>
```bash
npm run build
npm test
# Check that all project tools have annotations
grep -n "annotations:" src/infrastructure/tools/ToolSchemas.ts | head -40
```
Build passes and annotations are present.
  </verify>
  <done>All project-adjacent tools (labels, iterations, field values) have annotations</done>
</task>

</tasks>

<verification>
1. All 35+ project-related tools have `annotations` property
2. All project tools have `outputSchema` matching return type
3. Read-only tools marked with `readOnlyHint: true`
4. Delete tools marked with `destructiveHint: true`
5. Build and tests pass
</verification>

<success_criteria>
- Every project tool has behavior annotation
- Every project tool has output schema
- Annotations correctly reflect tool behavior (read-only, create, update, delete)
- Output schemas match actual service return types
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-protocol-compliance/02-04-SUMMARY.md`
</output>
