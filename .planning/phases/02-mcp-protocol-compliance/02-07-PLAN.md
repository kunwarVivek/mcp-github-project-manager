---
phase: 02-mcp-protocol-compliance
plan: 07
type: execute
wave: 6
depends_on: ["02-03", "02-06"]
files_modified:
  - src/infrastructure/tools/ToolResultFormatter.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "All 84 tools execute successfully with new SDK"
    - "Tool results include structuredContent when outputSchema is defined"
    - "Protocol version negotiation works correctly"
    - "Error responses include proper MCP error codes"
  artifacts:
    - path: "src/infrastructure/tools/ToolResultFormatter.ts"
      provides: "Updated formatter with structuredContent support"
      contains: "structuredContent"
  key_links:
    - from: "src/index.ts"
      to: "src/infrastructure/tools/ToolRegistry.ts"
      via: "getToolsForMCP call"
      pattern: "getToolsForMCP"
---

<objective>
Verify all tools work with MCP SDK 1.25.2 and update result formatting for structuredContent.

Purpose: Final verification that all MCP protocol compliance requirements are met.
Output: All 84 tools working, structuredContent in responses, proper error handling.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-protocol-compliance/02-RESEARCH.md
@.planning/phases/02-mcp-protocol-compliance/02-03-SUMMARY.md
@.planning/phases/02-mcp-protocol-compliance/02-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ToolResultFormatter for structuredContent</name>
  <files>src/infrastructure/tools/ToolResultFormatter.ts</files>
  <action>
Update ToolResultFormatter to include structuredContent in tool responses:

1. Find the ToolResultFormatter class and update its methods to return structuredContent:

```typescript
import { MCPContentType } from "../../domain/mcp-types.js";

export interface ToolResult {
  content: Array<{
    type: MCPContentType;
    text?: string;
    data?: string;
    mimeType?: string;
  }>;
  structuredContent?: unknown;
  isError?: boolean;
}

export class ToolResultFormatter {
  /**
   * Format successful tool result with optional structured content
   */
  static success<T>(data: T, options?: {
    includeStructured?: boolean;
    mimeType?: string;
  }): ToolResult {
    const text = typeof data === "string" ? data : JSON.stringify(data, null, 2);

    return {
      content: [{
        type: MCPContentType.TEXT,
        text,
      }],
      // Include structuredContent for backwards compatibility with clients that support it
      structuredContent: options?.includeStructured !== false ? data : undefined,
    };
  }

  /**
   * Format tool error result
   */
  static error(message: string, data?: unknown): ToolResult {
    return {
      content: [{
        type: MCPContentType.TEXT,
        text: `Error: ${message}`,
      }],
      structuredContent: data ? { error: message, details: data } : { error: message },
      isError: true,
    };
  }

  /**
   * Format result with explicit text and structured content
   */
  static withStructured<T>(textContent: string, structuredData: T): ToolResult {
    return {
      content: [{
        type: MCPContentType.TEXT,
        text: textContent,
      }],
      structuredContent: structuredData,
    };
  }
}
```

2. Ensure existing tool implementations use the updated formatter. Most tools likely use `ToolResultFormatter.success()` which now includes structuredContent by default.

3. Update any tools that format results differently to include structuredContent for consistency.
  </action>
  <verify>
```bash
npm run build
npm test
```
Build passes and tests work with new formatter.
  </verify>
  <done>ToolResultFormatter includes structuredContent in all responses</done>
</task>

<task type="auto">
  <name>Task 2: Verify all tools register and list correctly</name>
  <files>src/index.ts</files>
  <action>
Add verification that all tools are registered correctly:

1. Add a debug log on server startup to verify tool count:
```typescript
// After tool registration
const registeredTools = this.toolRegistry.getToolsForMCP();
this.logger.info(`Registered ${registeredTools.length} tools`);

// Verify all tools have annotations (in debug mode)
if (process.env.DEBUG) {
  const toolsWithAnnotations = registeredTools.filter(t => t.annotations);
  const toolsWithOutputSchema = registeredTools.filter(t => t.outputSchema);
  this.logger.debug(`Tools with annotations: ${toolsWithAnnotations.length}/${registeredTools.length}`);
  this.logger.debug(`Tools with outputSchema: ${toolsWithOutputSchema.length}/${registeredTools.length}`);
}
```

2. Verify the ListToolsRequestSchema handler returns annotations and outputSchema:
```typescript
this.server.setRequestHandler(ListToolsRequestSchema, async () => {
  const tools = this.toolRegistry.getToolsForMCP();
  return { tools };
});
```

This should already be the case, but verify the response includes:
- name, description, inputSchema (existing)
- title, outputSchema, annotations (new)

3. Verify tool count is 84 (or the correct current count).
  </action>
  <verify>
```bash
npm run build
# Start server and check logs for tool count
npm start 2>&1 | head -20 || true
```
Server logs should show 84 tools registered.
  </verify>
  <done>All tools registered with annotations and outputSchemas visible in list_tools</done>
</task>

<task type="auto">
  <name>Task 3: Verify error handling and protocol compliance</name>
  <files>N/A (verification only)</files>
  <action>
Run comprehensive verification:

1. Run the full test suite:
```bash
npm test
```
Expected: All 342+ tests pass (same as Phase 1 completion, possibly more with new tests)

2. Run build to verify TypeScript compliance:
```bash
npm run build
```
Expected: No errors

3. Create a verification script or use existing tests to verify:
   - Error responses include proper MCP error codes
   - GitHub API errors map to appropriate codes
   - Rate limit errors include retryAfter data

4. Check that all requirements are met:
   - MCP-01: SDK 1.25.2 in package.json ✓ (Plan 02-01)
   - MCP-02: Imports updated ✓ (Plan 02-01)
   - MCP-03: All tools work (this task)
   - MCP-04: Protocol version negotiation (Plan 02-03)
   - MCP-05: Destructive tool annotations ✓ (Plans 02-04 to 02-06)
   - MCP-06: Read-only annotations ✓ (Plans 02-04 to 02-06)
   - MCP-07: Idempotent annotations ✓ (Plans 02-04 to 02-06)
   - MCP-08 to MCP-12: Output schemas ✓ (Plans 02-04 to 02-06)
   - MCP-13: MCP error codes ✓ (Plan 02-03)
   - MCP-14: Error data payloads ✓ (Plan 02-03)
   - MCP-15: Protocol version handling ✓ (Plan 02-03)

5. Summarize any gaps or issues found for potential gap closure plan.
  </action>
  <verify>
```bash
npm run build && npm test
# Verify package.json has correct SDK version
grep "@modelcontextprotocol/sdk" package.json
```
All tests pass and SDK version is 1.25.x.
  </verify>
  <done>All MCP protocol compliance requirements verified</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm test` passes all tests (342+)
3. All 84 tools have annotations visible in getToolsForMCP()
4. All 84 tools have outputSchema (where applicable)
5. Error responses follow MCP error code format
6. Tool results include structuredContent
</verification>

<success_criteria>
- MCP SDK 1.25.2 installed and working
- All 84 tools execute successfully
- Every tool has behavior annotations
- Every tool has output schema
- Error handling uses MCP-compliant codes
- Protocol version is handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-protocol-compliance/02-07-SUMMARY.md`

This is the final plan of Phase 2. After this plan completes, the phase success criteria should be verified:
1. MCP SDK version is 1.25.2 in package.json
2. All 84 tools execute successfully with new SDK
3. Every destructive tool has behavior annotation visible to clients
4. Every tool has output schema that matches actual return type
5. Error responses include proper MCP error codes and data payloads
</output>
