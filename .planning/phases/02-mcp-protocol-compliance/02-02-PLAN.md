---
phase: 02-mcp-protocol-compliance
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/infrastructure/tools/ToolValidator.ts
  - src/infrastructure/tools/ToolRegistry.ts
  - src/infrastructure/tools/annotations/tool-annotations.ts
autonomous: true

must_haves:
  truths:
    - "ToolDefinition interface includes annotations and outputSchema fields"
    - "getToolsForMCP returns tools with annotations property"
    - "Annotation constants are defined for each behavior pattern"
    - "zod-to-json-schema is used for schema conversion"
  artifacts:
    - path: "src/infrastructure/tools/ToolValidator.ts"
      provides: "Extended ToolDefinition interface"
      contains: "annotations"
    - path: "src/infrastructure/tools/annotations/tool-annotations.ts"
      provides: "Annotation pattern constants"
      exports: ["ANNOTATION_PATTERNS", "ToolAnnotations"]
  key_links:
    - from: "src/infrastructure/tools/ToolRegistry.ts"
      to: "zod-to-json-schema"
      via: "import and usage"
      pattern: "zodToJsonSchema"
---

<objective>
Extend tool infrastructure to support MCP annotations and output schemas.

Purpose: Enable tools to declare behavior (read-only, destructive, idempotent) and output types for client consumption.
Output: Extended ToolDefinition interface, annotation constants, updated getToolsForMCP method.
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-protocol-compliance/02-RESEARCH.md
@.planning/phases/02-mcp-protocol-compliance/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ToolDefinition interface with annotations and outputSchema</name>
  <files>src/infrastructure/tools/ToolValidator.ts</files>
  <action>
Update the ToolDefinition interface in ToolValidator.ts:

1. Add ToolAnnotations interface:
```typescript
export interface ToolAnnotations {
  title?: string;
  readOnlyHint?: boolean;     // Default: false - tool only reads data
  destructiveHint?: boolean;  // Default: true when readOnly=false - tool may delete/modify
  idempotentHint?: boolean;   // Default: false - repeated calls have same effect
  openWorldHint?: boolean;    // Default: true - tool interacts with external world
}
```

2. Extend ToolDefinition to include annotations and outputSchema:
```typescript
export interface ToolDefinition<TInput, TOutput = unknown> {
  name: string;
  title?: string;
  description: string;
  schema: ToolSchema<TInput>;
  outputSchema?: z.ZodType<TOutput>;
  annotations?: ToolAnnotations;
  examples?: Array<{
    name: string;
    description: string;
    args: TInput;
  }>;
}
```

Note: TOutput generic defaults to unknown for backward compatibility with existing tool definitions that don't have output schemas yet.

3. Export ToolAnnotations from the module.
  </action>
  <verify>
```bash
npm run build
```
Build should pass - existing tools still work because new fields are optional.
  </verify>
  <done>ToolDefinition interface has annotations and outputSchema fields</done>
</task>

<task type="auto">
  <name>Task 2: Create annotation pattern constants</name>
  <files>src/infrastructure/tools/annotations/tool-annotations.ts</files>
  <action>
Create new file at src/infrastructure/tools/annotations/tool-annotations.ts:

```typescript
import { ToolAnnotations } from "../ToolValidator.js";

/**
 * Standard annotation patterns for tool behavior classification.
 * Based on MCP specification 2025-11-25.
 */
export const ANNOTATION_PATTERNS = {
  /**
   * Read-only tools (queries) - safe to call repeatedly
   * Examples: get_project, list_issues, get_field_value
   */
  readOnly: {
    readOnlyHint: true,
    destructiveHint: false,
    idempotentHint: true,  // Safe to retry
    openWorldHint: true    // GitHub API is external
  } as ToolAnnotations,

  /**
   * Create operations - adds new resources
   * Examples: create_project, create_issue, create_milestone
   */
  create: {
    readOnlyHint: false,
    destructiveHint: false,  // Creates, doesn't destroy
    idempotentHint: false,   // Multiple calls create multiple resources
    openWorldHint: true
  } as ToolAnnotations,

  /**
   * Idempotent update operations - same args = same result
   * Examples: set_field_value, update_project (setting to specific state)
   */
  updateIdempotent: {
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: true,
    openWorldHint: true
  } as ToolAnnotations,

  /**
   * Non-idempotent update operations - may have cumulative effects
   * Examples: add_issue_comment (adds new comment each time)
   */
  updateNonIdempotent: {
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
    openWorldHint: true
  } as ToolAnnotations,

  /**
   * Delete operations - removes resources
   * Examples: delete_project, delete_issue, remove_project_item
   */
  delete: {
    readOnlyHint: false,
    destructiveHint: true,
    idempotentHint: true,  // Deleting twice = same as once
    openWorldHint: true
  } as ToolAnnotations,

  /**
   * AI-powered operations - may be slow, not deterministic
   * Examples: generate_prd, analyze_task_complexity
   */
  aiOperation: {
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,  // AI output may vary
    openWorldHint: true     // May call external AI services
  } as ToolAnnotations
} as const;

export type AnnotationPatternKey = keyof typeof ANNOTATION_PATTERNS;
```

Create the annotations directory if it doesn't exist.
  </action>
  <verify>
```bash
ls src/infrastructure/tools/annotations/
npm run build
```
File exists and build passes.
  </verify>
  <done>Annotation pattern constants defined for all behavior types</done>
</task>

<task type="auto">
  <name>Task 3: Update getToolsForMCP to emit annotations and output schemas</name>
  <files>src/infrastructure/tools/ToolRegistry.ts</files>
  <action>
Update ToolRegistry.ts to use zod-to-json-schema and emit annotations:

1. Add import at top of file:
```typescript
import zodToJsonSchema from "zod-to-json-schema";
```

2. Update the getToolsForMCP method return type and implementation:
```typescript
/**
 * Convert tools to MCP format for list_tools response
 */
public getToolsForMCP(): Array<{
  name: string;
  title?: string;
  description: string;
  inputSchema: Record<string, unknown>;
  outputSchema?: Record<string, unknown>;
  annotations?: {
    title?: string;
    readOnlyHint?: boolean;
    destructiveHint?: boolean;
    idempotentHint?: boolean;
    openWorldHint?: boolean;
  };
}> {
  return this.getAllTools().map(tool => ({
    name: tool.name,
    title: tool.title,
    description: tool.description,
    inputSchema: zodToJsonSchema(tool.schema, { $refStrategy: "none" }),
    outputSchema: tool.outputSchema
      ? zodToJsonSchema(tool.outputSchema, { $refStrategy: "none" })
      : undefined,
    annotations: tool.annotations,
  }));
}
```

3. Remove or mark as deprecated the old convertZodToJsonSchema and zodTypeToJsonSchemaType methods since we now use zod-to-json-schema library.

Note: Use { $refStrategy: "none" } to inline all definitions instead of using $ref, which is simpler for MCP clients.
  </action>
  <verify>
```bash
npm run build
npm test
```
Build passes and tests still work with new schema conversion.
  </verify>
  <done>getToolsForMCP uses zod-to-json-schema and emits annotations</done>
</task>

</tasks>

<verification>
1. ToolDefinition interface includes `annotations?: ToolAnnotations` and `outputSchema?: z.ZodType<TOutput>`
2. ANNOTATION_PATTERNS exported from annotations/tool-annotations.ts
3. getToolsForMCP uses zodToJsonSchema library
4. Build and tests pass
</verification>

<success_criteria>
- Extended ToolDefinition supports annotations and output schemas
- Annotation patterns defined for read-only, create, update, delete, AI operations
- zod-to-json-schema produces proper JSON Schema for MCP
- All existing tools continue to work (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-protocol-compliance/02-02-SUMMARY.md`
</output>
