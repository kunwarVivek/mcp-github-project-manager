---
phase: 10-ai-sprint-roadmap-planning
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/services/ai/SprintCapacityAnalyzer.ts
  - src/services/ai/BacklogPrioritizer.ts
  - src/services/ai/SprintRiskAssessor.ts
  - src/services/ai/SprintSuggestionService.ts
  - src/services/ai/prompts/SprintPlanningPrompts.ts
autonomous: true

must_haves:
  truths:
    - "AI can calculate sprint capacity with velocity and buffer"
    - "AI can prioritize backlog items using multi-factor scoring"
    - "AI can assess sprint risks with mitigation suggestions"
    - "AI can suggest sprint composition within capacity constraints"
  artifacts:
    - path: "src/services/ai/SprintCapacityAnalyzer.ts"
      provides: "Capacity calculation with velocity calibration"
      exports: ["SprintCapacityAnalyzer"]
    - path: "src/services/ai/BacklogPrioritizer.ts"
      provides: "Multi-factor prioritization with AI reasoning"
      exports: ["BacklogPrioritizer"]
    - path: "src/services/ai/SprintRiskAssessor.ts"
      provides: "Risk assessment with mitigation suggestions"
      exports: ["SprintRiskAssessor"]
    - path: "src/services/ai/SprintSuggestionService.ts"
      provides: "Combined sprint composition suggestions"
      exports: ["SprintSuggestionService"]
  key_links:
    - from: "src/services/ai/SprintSuggestionService.ts"
      to: "src/services/ai/AIServiceFactory.ts"
      via: "AI model selection"
      pattern: "AIServiceFactory"
    - from: "src/services/ai/BacklogPrioritizer.ts"
      to: "src/analysis/DependencyGraph.ts"
      via: "Dependency analysis for prioritization"
      pattern: "DependencyGraph"
    - from: "src/services/ai/SprintCapacityAnalyzer.ts"
      to: "src/analysis/EstimationCalibrator.ts"
      via: "Velocity calibration"
      pattern: "EstimationCalibrator"
---

<objective>
Implement AI services for sprint capacity planning, backlog prioritization, and risk assessment.

Purpose: Cover requirements AI-09 (capacity planning), AI-10 (prioritization), AI-11 (risk assessment), AI-12 (scope recommendations).

Output:
- `SprintCapacityAnalyzer` - Calculate capacity with velocity and buffer
- `BacklogPrioritizer` - Multi-factor prioritization with DependencyGraph
- `SprintRiskAssessor` - Risk identification with mitigations
- `SprintSuggestionService` - Combined composition suggestions
- `SprintPlanningPrompts` - AI prompt templates
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ai-sprint-roadmap-planning/10-RESEARCH.md
@.planning/phases/10-ai-sprint-roadmap-planning/10-01-SUMMARY.md
@src/domain/sprint-planning-types.ts
@src/services/ai/AIServiceFactory.ts
@src/services/ai/ConfidenceScorer.ts
@src/analysis/DependencyGraph.ts
@src/analysis/EstimationCalibrator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SprintCapacityAnalyzer and SprintPlanningPrompts</name>
  <files>src/services/ai/SprintCapacityAnalyzer.ts, src/services/ai/prompts/SprintPlanningPrompts.ts</files>
  <action>
**First, create prompts file at `src/services/ai/prompts/SprintPlanningPrompts.ts`:**

Export prompt templates:
1. `SPRINT_CAPACITY_SYSTEM_PROMPT` - System prompt for capacity analysis
2. `SPRINT_PRIORITIZATION_SYSTEM_PROMPT` - System prompt for backlog prioritization
3. `SPRINT_RISK_SYSTEM_PROMPT` - System prompt for risk assessment
4. `SPRINT_SUGGESTION_SYSTEM_PROMPT` - System prompt for composition suggestions

Each prompt should include:
- Role definition (sprint planning expert)
- Key principles (sustainability, buffer, velocity)
- Output requirements (structured, with reasoning)

**Then, create SprintCapacityAnalyzer at `src/services/ai/SprintCapacityAnalyzer.ts`:**

```typescript
import { EstimationCalibrator } from '../../analysis/EstimationCalibrator';
import { ConfidenceScorer, calculateWeightedScore, getConfidenceTier } from './ConfidenceScorer';
import { SprintCapacity, TeamMember, BacklogItem } from '../../domain/sprint-planning-types';
import { SectionConfidence } from '../../domain/ai-types';

export class SprintCapacityAnalyzer {
  constructor(
    private estimationCalibrator?: EstimationCalibrator
  ) {}

  /**
   * Calculate sprint capacity with buffer and confidence
   */
  async calculateCapacity(params: {
    velocity: number | 'auto';
    sprintDurationDays: number;
    teamMembers: TeamMember[];
    historicalSprints?: SprintMetrics[];
  }): Promise<SprintCapacity> {
    // 1. Determine velocity
    const velocity = params.velocity === 'auto'
      ? this.calculateVelocityFromHistory(params.historicalSprints || [])
      : params.velocity;

    // 2. Calculate team availability factor
    const availabilityFactor = this.calculateTeamAvailability(params.teamMembers);

    // 3. Apply calibration from EstimationCalibrator if available
    const calibrationFactor = this.estimationCalibrator?.getCalibrationFactor('medium') ?? 1.0;
    const calibratedVelocity = Math.floor(velocity * availabilityFactor * calibrationFactor);

    // 4. Apply 20% buffer for sustainability
    const bufferPercentage = 0.20;
    const recommendedLoad = Math.floor(calibratedVelocity * (1 - bufferPercentage));

    // 5. Calculate confidence
    const hasHistoricalData = (params.historicalSprints?.length ?? 0) >= 3;
    const confidence = this.calculateConfidence(hasHistoricalData, availabilityFactor);

    return {
      totalPoints: calibratedVelocity,
      recommendedLoad,
      teamAvailability: {
        totalMembers: params.teamMembers.length,
        effectiveCapacity: availabilityFactor,
        adjustments: this.getAvailabilityAdjustments(params.teamMembers)
      },
      buffer: {
        percentage: bufferPercentage * 100,
        reasoning: 'Standard 20% buffer for unexpected work and sustainable pace'
      },
      confidence
    };
  }

  private calculateVelocityFromHistory(sprints: SprintMetrics[]): number {
    // Average of last 3-5 sprints with outlier filtering
    if (sprints.length === 0) return 20; // Default velocity
    // Implementation details...
  }

  private calculateTeamAvailability(members: TeamMember[]): number {
    // Sum of member availabilities / team size
    if (members.length === 0) return 1;
    return members.reduce((sum, m) => sum + m.availability, 0) / members.length;
  }

  private calculateConfidence(hasHistory: boolean, availability: number): SectionConfidence {
    const factors = {
      inputCompleteness: hasHistory ? 0.8 : 0.4,
      aiSelfAssessment: 0.7,
      patternMatch: availability > 0.5 ? 0.8 : 0.5
    };
    const score = calculateWeightedScore(factors);
    return {
      score,
      tier: getConfidenceTier(score),
      factors,
      reasoning: hasHistory
        ? 'Based on historical velocity data'
        : 'Estimate based on team size and default velocity'
    };
  }
}
```

Add SprintMetrics interface if needed (or import from sprint-planning-types).
  </action>
  <verify>npx tsc --noEmit src/services/ai/SprintCapacityAnalyzer.ts src/services/ai/prompts/SprintPlanningPrompts.ts</verify>
  <done>SprintCapacityAnalyzer calculates capacity with velocity calibration and confidence scoring</done>
</task>

<task type="auto">
  <name>Task 2: Create BacklogPrioritizer with multi-factor scoring</name>
  <files>src/services/ai/BacklogPrioritizer.ts</files>
  <action>
Create BacklogPrioritizer that combines AI and algorithmic scoring:

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';
import { DependencyGraph, GraphAnalysisResult } from '../../analysis/DependencyGraph';
import { AIServiceFactory } from './AIServiceFactory';
import { ConfidenceScorer, calculateWeightedScore, getConfidenceTier } from './ConfidenceScorer';
import {
  BacklogItem,
  PrioritizedItem,
  PrioritizationResult
} from '../../domain/sprint-planning-types';
import { SPRINT_PRIORITIZATION_SYSTEM_PROMPT } from './prompts/SprintPlanningPrompts';

// Zod schema for AI business value scoring
const AIBusinessValueSchema = z.object({
  items: z.array(z.object({
    itemId: z.string(),
    businessValue: z.number().min(0).max(1),
    reasoning: z.string()
  })),
  tradeoffs: z.array(z.string())
});

export class BacklogPrioritizer {
  private aiFactory: AIServiceFactory;

  constructor() {
    this.aiFactory = AIServiceFactory.getInstance();
  }

  async prioritize(params: {
    backlogItems: BacklogItem[];
    sprintCapacity: number;
    businessGoals?: string[];
    riskTolerance?: 'low' | 'medium' | 'high';
  }): Promise<PrioritizationResult> {
    // 1. Build dependency graph
    const dependencyGraph = new DependencyGraph();
    const aiTasks = params.backlogItems.map(item => ({
      id: item.id,
      title: item.title,
      description: item.description || '',
      complexity: Math.min(10, Math.max(1, Math.ceil((item.points || 3) / 2))) as any,
      dependencies: (item.dependencies || []).map(d => ({ id: d, type: 'depends_on' as const }))
    }));
    dependencyGraph.addTasks(aiTasks);

    // 2. Detect implicit dependencies
    dependencyGraph.detectImplicitDependencies(0.5);
    const graphAnalysis = dependencyGraph.analyze();

    // 3. Get AI business value scoring
    const aiScoring = await this.getAIBusinessValueScoring(
      params.backlogItems,
      params.businessGoals || []
    );

    // 4. Calculate composite scores with weights
    const weights = { businessValue: 0.4, dependencies: 0.25, risk: 0.2, effort: 0.15 };
    const scored = this.calculateCompositeScores(
      params.backlogItems,
      aiScoring,
      graphAnalysis,
      params.sprintCapacity,
      weights
    );

    // 5. Sort and assign priority tiers
    const prioritized = this.assignPriorityTiers(scored);

    // 6. Calculate confidence
    const confidence = this.calculateConfidence(params.backlogItems, aiScoring);

    return {
      prioritizedItems: prioritized,
      reasoning: {
        methodology: 'Multi-factor weighted prioritization with AI-assessed business value',
        weightings: weights,
        tradeoffs: aiScoring.tradeoffs
      },
      confidence
    };
  }

  private async getAIBusinessValueScoring(
    items: BacklogItem[],
    goals: string[]
  ): Promise<{ items: { itemId: string; businessValue: number; reasoning: string }[]; tradeoffs: string[] }> {
    const model = this.aiFactory.getModel('main') || this.aiFactory.getBestAvailableModel();

    if (!model) {
      // Fallback: use priority as proxy for business value
      return {
        items: items.map(item => ({
          itemId: item.id,
          businessValue: this.priorityToValue(item.priority),
          reasoning: 'Fallback: derived from priority level'
        })),
        tradeoffs: []
      };
    }

    const result = await generateObject({
      model,
      system: SPRINT_PRIORITIZATION_SYSTEM_PROMPT,
      prompt: this.formatPrioritizationPrompt(items, goals),
      schema: AIBusinessValueSchema,
      temperature: 0.3
    });

    return result.object;
  }

  private calculateCompositeScores(
    items: BacklogItem[],
    aiScoring: any,
    graphAnalysis: GraphAnalysisResult,
    capacity: number,
    weights: { businessValue: number; dependencies: number; risk: number; effort: number }
  ): Array<BacklogItem & { score: number; factors: any }> {
    // Map AI scores by item ID
    const aiScoreMap = new Map(aiScoring.items.map(i => [i.itemId, i]));

    return items.map(item => {
      const aiScore = aiScoreMap.get(item.id);
      const businessValue = aiScore?.businessValue ?? 0.5;

      // Dependency score: higher if in orphanTasks (can start immediately)
      const dependencyScore = graphAnalysis.orphanTasks.includes(item.id) ? 1.0 :
        graphAnalysis.criticalPath.includes(item.id) ? 0.8 : 0.5;

      // Risk score: lower priority = higher risk tolerance
      const riskScore = 1 - (this.priorityToValue(item.priority) * 0.3);

      // Effort fit: how well does it fit remaining capacity
      const points = item.points || 3;
      const effortFit = points <= capacity * 0.3 ? 1.0 : points <= capacity * 0.5 ? 0.7 : 0.4;

      const score = Math.round(
        (businessValue * weights.businessValue +
         dependencyScore * weights.dependencies +
         riskScore * weights.risk +
         effortFit * weights.effort) * 100
      );

      return {
        ...item,
        score,
        factors: { businessValue, dependencyScore, riskScore, effortFit }
      };
    });
  }

  private assignPriorityTiers(scored: Array<BacklogItem & { score: number; factors: any }>): PrioritizedItem[] {
    return scored
      .sort((a, b) => b.score - a.score)
      .map(item => ({
        itemId: item.id,
        priority: item.score >= 80 ? 'critical' :
                 item.score >= 60 ? 'high' :
                 item.score >= 40 ? 'medium' : 'low',
        score: item.score,
        factors: item.factors,
        reasoning: `Score ${item.score}: BV=${item.factors.businessValue.toFixed(2)}, Dep=${item.factors.dependencyScore.toFixed(2)}`
      }));
  }

  private priorityToValue(priority?: string): number {
    switch (priority) {
      case 'critical': return 1.0;
      case 'high': return 0.75;
      case 'medium': return 0.5;
      case 'low': return 0.25;
      default: return 0.5;
    }
  }
}
```

Include proper error handling and fallback when AI is unavailable.
  </action>
  <verify>npx tsc --noEmit src/services/ai/BacklogPrioritizer.ts</verify>
  <done>BacklogPrioritizer combines AI business value scoring with algorithmic dependency and effort analysis</done>
</task>

<task type="auto">
  <name>Task 3: Create SprintRiskAssessor and SprintSuggestionService</name>
  <files>src/services/ai/SprintRiskAssessor.ts, src/services/ai/SprintSuggestionService.ts</files>
  <action>
**Create SprintRiskAssessor at `src/services/ai/SprintRiskAssessor.ts`:**

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';
import { AIServiceFactory } from './AIServiceFactory';
import { ConfidenceScorer, calculateWeightedScore, getConfidenceTier } from './ConfidenceScorer';
import {
  SprintRiskAssessment,
  SprintRisk,
  MitigationSuggestion,
  BacklogItem,
  SprintCapacity
} from '../../domain/sprint-planning-types';
import { DetectedDependency } from '../../analysis/DependencyGraph';
import { SPRINT_RISK_SYSTEM_PROMPT } from './prompts/SprintPlanningPrompts';

const SprintRiskAssessmentSchema = z.object({
  overallRisk: z.enum(['high', 'medium', 'low']),
  riskScore: z.number().min(0).max(100),
  risks: z.array(z.object({
    id: z.string(),
    category: z.enum(['scope', 'dependency', 'capacity', 'technical', 'external']),
    title: z.string(),
    description: z.string(),
    probability: z.enum(['high', 'medium', 'low']),
    impact: z.enum(['high', 'medium', 'low']),
    relatedItems: z.array(z.string())
  })),
  mitigations: z.array(z.object({
    riskId: z.string(),
    strategy: z.enum(['avoid', 'mitigate', 'transfer', 'accept']),
    action: z.string(),
    effort: z.enum(['low', 'medium', 'high']),
    effectiveness: z.number().min(0).max(1)
  })),
  reasoning: z.string()
});

export class SprintRiskAssessor {
  private aiFactory: AIServiceFactory;

  constructor() {
    this.aiFactory = AIServiceFactory.getInstance();
  }

  async assessRisks(params: {
    sprintItems: BacklogItem[];
    sprintCapacity: SprintCapacity;
    dependencies?: DetectedDependency[];
    historicalData?: SprintMetrics[];
  }): Promise<SprintRiskAssessment> {
    const model = this.aiFactory.getModel('main') || this.aiFactory.getBestAvailableModel();

    if (!model) {
      return this.getFallbackAssessment(params);
    }

    try {
      const result = await generateObject({
        model,
        system: SPRINT_RISK_SYSTEM_PROMPT,
        prompt: this.formatRiskPrompt(params),
        schema: SprintRiskAssessmentSchema,
        temperature: 0.3
      });

      // Add confidence scoring
      const confidence = this.calculateConfidence(params, result.object.riskScore);

      return {
        ...result.object,
        confidence
      };
    } catch (error) {
      return this.getFallbackAssessment(params);
    }
  }

  private getFallbackAssessment(params: any): SprintRiskAssessment {
    // Algorithmic risk detection based on capacity and dependencies
    const risks: SprintRisk[] = [];
    const totalPoints = params.sprintItems.reduce((sum, i) => sum + (i.points || 3), 0);
    const utilizationRatio = totalPoints / params.sprintCapacity.recommendedLoad;

    if (utilizationRatio > 1.0) {
      risks.push({
        id: 'capacity-1',
        category: 'capacity',
        title: 'Sprint overcommitment',
        description: `Sprint scope (${totalPoints} points) exceeds recommended capacity (${params.sprintCapacity.recommendedLoad} points)`,
        probability: 'high',
        impact: 'high',
        relatedItems: params.sprintItems.map(i => i.id)
      });
    }

    return {
      overallRisk: risks.length > 0 ? 'high' : 'low',
      riskScore: Math.min(100, risks.length * 30),
      risks,
      mitigations: risks.map(r => ({
        riskId: r.id,
        strategy: 'mitigate' as const,
        action: 'Reduce sprint scope or extend timeline',
        effort: 'medium' as const,
        effectiveness: 0.7
      })),
      confidence: {
        score: 50,
        tier: 'medium',
        factors: { inputCompleteness: 0.5, aiSelfAssessment: 0.5, patternMatch: 0.5 },
        reasoning: 'Fallback algorithmic assessment'
      }
    };
  }
}
```

**Create SprintSuggestionService at `src/services/ai/SprintSuggestionService.ts`:**

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';
import { AIServiceFactory } from './AIServiceFactory';
import { SprintCapacityAnalyzer } from './SprintCapacityAnalyzer';
import { BacklogPrioritizer } from './BacklogPrioritizer';
import { SprintRiskAssessor } from './SprintRiskAssessor';
import { DependencyGraph } from '../../analysis/DependencyGraph';
import { ConfidenceScorer, calculateWeightedScore, getConfidenceTier } from './ConfidenceScorer';
import {
  SprintSuggestion,
  SuggestedItem,
  BacklogItem,
  TeamMember
} from '../../domain/sprint-planning-types';
import { SPRINT_SUGGESTION_SYSTEM_PROMPT } from './prompts/SprintPlanningPrompts';

const SprintSuggestionSchema = z.object({
  suggestedItems: z.array(z.object({
    itemId: z.string(),
    title: z.string(),
    points: z.number(),
    priority: z.enum(['critical', 'high', 'medium', 'low']),
    includeReason: z.string(),
    dependencies: z.array(z.string())
  })),
  totalPoints: z.number(),
  capacityUtilization: z.number().min(0).max(1),
  reasoning: z.string(),
  risks: z.array(z.object({
    category: z.string(),
    description: z.string(),
    probability: z.enum(['high', 'medium', 'low']),
    mitigation: z.string()
  }))
});

export class SprintSuggestionService {
  private aiFactory: AIServiceFactory;
  private capacityAnalyzer: SprintCapacityAnalyzer;
  private prioritizer: BacklogPrioritizer;
  private riskAssessor: SprintRiskAssessor;

  constructor() {
    this.aiFactory = AIServiceFactory.getInstance();
    this.capacityAnalyzer = new SprintCapacityAnalyzer();
    this.prioritizer = new BacklogPrioritizer();
    this.riskAssessor = new SprintRiskAssessor();
  }

  async suggestSprintComposition(params: {
    backlogItems: BacklogItem[];
    velocity: number;
    sprintDurationDays: number;
    teamMembers?: TeamMember[];
    businessGoals?: string[];
    riskTolerance?: 'low' | 'medium' | 'high';
  }): Promise<SprintSuggestion> {
    // 1. Calculate capacity
    const capacity = await this.capacityAnalyzer.calculateCapacity({
      velocity: params.velocity,
      sprintDurationDays: params.sprintDurationDays,
      teamMembers: params.teamMembers || []
    });

    // 2. Get prioritization
    const prioritization = await this.prioritizer.prioritize({
      backlogItems: params.backlogItems,
      sprintCapacity: capacity.recommendedLoad,
      businessGoals: params.businessGoals,
      riskTolerance: params.riskTolerance
    });

    // 3. Build dependency graph for selection
    const dependencyGraph = new DependencyGraph();
    const aiTasks = params.backlogItems.map(item => ({
      id: item.id,
      title: item.title,
      description: item.description || '',
      complexity: 5 as any,
      dependencies: (item.dependencies || []).map(d => ({ id: d, type: 'depends_on' as const }))
    }));
    dependencyGraph.addTasks(aiTasks);
    const graphAnalysis = dependencyGraph.analyze();

    // 4. Select items that fit capacity, respecting dependencies
    const selectedItems = this.selectItemsForCapacity(
      prioritization.prioritizedItems,
      params.backlogItems,
      capacity.recommendedLoad,
      graphAnalysis
    );

    // 5. Calculate totals
    const totalPoints = selectedItems.reduce((sum, item) => sum + item.points, 0);
    const utilization = totalPoints / capacity.recommendedLoad;

    // 6. Assess risks for selected items
    const selectedBacklogItems = selectedItems.map(si =>
      params.backlogItems.find(bi => bi.id === si.itemId)!
    );
    const riskAssessment = await this.riskAssessor.assessRisks({
      sprintItems: selectedBacklogItems,
      sprintCapacity: capacity
    });

    // 7. Calculate confidence
    const confidence = this.calculateConfidence(params, utilization);

    return {
      suggestedItems: selectedItems,
      totalPoints,
      capacityUtilization: utilization,
      reasoning: this.generateReasoning(selectedItems, capacity, prioritization),
      risks: riskAssessment.risks,
      confidence
    };
  }

  private selectItemsForCapacity(
    prioritized: PrioritizedItem[],
    backlogItems: BacklogItem[],
    capacity: number,
    graphAnalysis: any
  ): SuggestedItem[] {
    const selected: SuggestedItem[] = [];
    let remainingCapacity = capacity;
    const includedIds = new Set<string>();

    // Sort by priority score descending
    const sorted = [...prioritized].sort((a, b) => b.score - a.score);

    for (const item of sorted) {
      const backlogItem = backlogItems.find(bi => bi.id === item.itemId);
      if (!backlogItem) continue;

      const points = backlogItem.points || 3;
      if (points <= remainingCapacity) {
        // Check if dependencies are included
        const deps = backlogItem.dependencies || [];
        const depsIncluded = deps.every(d => includedIds.has(d) || !backlogItems.find(bi => bi.id === d));

        if (depsIncluded) {
          selected.push({
            itemId: item.itemId,
            title: backlogItem.title,
            points,
            priority: item.priority,
            includeReason: item.reasoning,
            dependencies: deps
          });
          remainingCapacity -= points;
          includedIds.add(item.itemId);
        }
      }
    }

    return selected;
  }
}
```

Add proper error handling, fallback behavior, and confidence calculation methods.
  </action>
  <verify>npx tsc --noEmit src/services/ai/SprintRiskAssessor.ts src/services/ai/SprintSuggestionService.ts</verify>
  <done>SprintRiskAssessor and SprintSuggestionService implement complete sprint planning AI</done>
</task>

</tasks>

<verification>
1. All new services compile without TypeScript errors
2. Services use existing Phase 9 patterns (ConfidenceScorer, DependencyGraph, EstimationCalibrator)
3. AI fallback behavior works when model unavailable
4. Prompts are well-structured and exported
</verification>

<success_criteria>
1. SprintCapacityAnalyzer calculates capacity with velocity and 20% buffer
2. BacklogPrioritizer uses multi-factor scoring (business value, dependencies, risk, effort)
3. SprintRiskAssessor identifies risks with categories and mitigations
4. SprintSuggestionService combines all services for composition suggestions
5. All services have fallback behavior for AI unavailability
6. Confidence scores included in all outputs
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-sprint-roadmap-planning/10-02-SUMMARY.md`
</output>
