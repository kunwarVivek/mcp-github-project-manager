---
phase: 10-ai-sprint-roadmap-planning
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/services/ai/RoadmapAIService.ts
  - src/services/ai/prompts/RoadmapPrompts.ts
autonomous: true

must_haves:
  truths:
    - "AI can generate roadmap with phases and milestones from requirements"
    - "Phase sequencing respects dependencies between milestones"
    - "Milestone dates are calculated from velocity, not AI-generated"
    - "Visualization data is generated for Gantt-style rendering"
  artifacts:
    - path: "src/services/ai/RoadmapAIService.ts"
      provides: "Roadmap generation with phases, milestones, dependencies"
      exports: ["RoadmapAIService"]
    - path: "src/services/ai/prompts/RoadmapPrompts.ts"
      provides: "AI prompts for roadmap generation"
      exports: ["ROADMAP_GENERATION_SYSTEM_PROMPT"]
  key_links:
    - from: "src/services/ai/RoadmapAIService.ts"
      to: "src/services/ai/AIServiceFactory.ts"
      via: "AI model selection"
      pattern: "AIServiceFactory"
    - from: "src/services/ai/RoadmapAIService.ts"
      to: "src/analysis/EstimationCalibrator.ts"
      via: "Effort estimation for requirements"
      pattern: "EstimationCalibrator"
    - from: "src/services/ai/RoadmapAIService.ts"
      to: "src/domain/roadmap-planning-types.ts"
      via: "Roadmap types"
      pattern: "GeneratedRoadmap"
---

<objective>
Implement AI service for roadmap generation with phases, milestones, and velocity-grounded date estimation.

Purpose: Cover requirements AI-13 (roadmap generation), AI-14 (phase sequencing), AI-15 (milestone estimation), AI-16 (visualization data).

Output:
- `RoadmapAIService` - Generate structured roadmaps from requirements
- `RoadmapPrompts` - AI prompt templates for roadmap generation
</objective>

<execution_context>
@/Users/vivek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vivek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ai-sprint-roadmap-planning/10-RESEARCH.md
@.planning/phases/10-ai-sprint-roadmap-planning/10-01-SUMMARY.md
@src/domain/roadmap-planning-types.ts
@src/services/ai/AIServiceFactory.ts
@src/services/ai/ConfidenceScorer.ts
@src/analysis/EstimationCalibrator.ts
@src/services/RoadmapPlanningService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoadmapPrompts</name>
  <files>src/services/ai/prompts/RoadmapPrompts.ts</files>
  <action>
Create roadmap AI prompt templates:

```typescript
/**
 * AI prompts for roadmap generation
 */

export const ROADMAP_GENERATION_SYSTEM_PROMPT = `You are a product roadmap planning expert.
You create structured roadmaps with clear phases, realistic milestones, and explicit dependencies.

KEY PRINCIPLES:
1. Phases should be logically grouped by theme or capability area
2. Each phase should have 2-4 milestones
3. Milestones should be measurable and have clear deliverables
4. Dependencies should be explicit - what must complete before what starts
5. Later phases should build on earlier ones (progressive capability development)

PHASE GUIDELINES:
- Foundation phases (infrastructure, setup) come first
- Core features follow foundation
- Advanced features build on core
- Polish/optimization phases come last
- Each phase should be independently valuable (shippable)

MILESTONE GUIDELINES:
- Each milestone should have 3-5 deliverables
- Deliverables should be concrete, not abstract
- Include both technical and user-facing deliverables where appropriate
- Milestones within a phase can have internal dependencies

OUTPUT RULES:
- Use weekNumber for timing (relative weeks from start)
- Assign confidence based on how well-defined the requirements are
- Provide reasoning for phase ordering decisions`;

export const REQUIREMENTS_PARSING_PROMPT = `Parse the following requirements into structured format.
For each requirement, identify:
- A unique ID (if not provided, generate one like REQ-001)
- Title (concise summary)
- Description (detailed explanation)
- Priority (critical/high/medium/low based on language used)
- Estimated complexity (1-10 based on scope)
- Category (group related requirements)

Be conservative with priorities - not everything is critical.`;

export const PHASE_SEQUENCING_PROMPT = `Given the following requirements, group them into logical phases.

SEQUENCING RULES:
1. Infrastructure/setup requirements go in Phase 1
2. Data model/schema requirements follow infrastructure
3. Core API/backend requirements follow data model
4. UI/frontend requirements follow backend
5. Integration/external service requirements follow core
6. Advanced features follow basic features
7. Optimization/polish follows feature completion

For each phase:
- Give it a clear, descriptive name
- List 3-5 objectives
- Identify dependencies on prior phases
- Estimate duration in weeks`;

export const MILESTONE_ESTIMATION_PROMPT = `Create milestones for the given phase.

For each milestone:
- Title: Clear, outcome-focused name
- Description: What success looks like
- Deliverables: 3-5 specific outputs
- Dependencies: Other milestones that must complete first
- Confidence: 0-1 based on requirement clarity

ESTIMATION RULES:
- Milestones should be 1-3 weeks of work (at given velocity)
- Include buffer for integration and testing
- Earlier milestones in a phase should be more concrete
- Later milestones can be broader`;

/**
 * Format requirements for AI prompt
 */
export function formatRequirementsForPrompt(
  requirements: Array<{ id?: string; title: string; description?: string; priority?: string }>
): string {
  return requirements.map((req, i) =>
    `${i + 1}. ${req.id || `REQ-${String(i + 1).padStart(3, '0')}`}: ${req.title}
   ${req.description ? `Description: ${req.description}` : ''}
   ${req.priority ? `Priority: ${req.priority}` : ''}`
  ).join('\n\n');
}

/**
 * Format constraints for AI prompt
 */
export function formatConstraintsForPrompt(constraints?: {
  timeline?: string;
  teamSize?: number;
  velocity?: number;
  sprintDurationWeeks?: number;
}): string {
  if (!constraints) return '';

  const parts: string[] = [];
  if (constraints.timeline) parts.push(`Target timeline: ${constraints.timeline}`);
  if (constraints.teamSize) parts.push(`Team size: ${constraints.teamSize} people`);
  if (constraints.velocity) parts.push(`Team velocity: ${constraints.velocity} points/sprint`);
  if (constraints.sprintDurationWeeks) parts.push(`Sprint duration: ${constraints.sprintDurationWeeks} weeks`);

  return parts.length > 0 ? `\nCONSTRAINTS:\n${parts.join('\n')}` : '';
}
```

Export all prompts and helper functions.
  </action>
  <verify>npx tsc --noEmit src/services/ai/prompts/RoadmapPrompts.ts</verify>
  <done>RoadmapPrompts exports all prompt templates and formatting helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create RoadmapAIService with phase sequencing</name>
  <files>src/services/ai/RoadmapAIService.ts</files>
  <action>
Create RoadmapAIService that generates structured roadmaps:

```typescript
import { generateObject } from 'ai';
import { z } from 'zod';
import { AIServiceFactory } from './AIServiceFactory';
import { EstimationCalibrator, complexityToPoints } from '../../analysis/EstimationCalibrator';
import { ConfidenceScorer, calculateWeightedScore, getConfidenceTier } from './ConfidenceScorer';
import {
  GeneratedRoadmap,
  RoadmapPhase,
  RoadmapMilestone,
  MilestoneDependency,
  RoadmapGenerationInput,
  RequirementItem,
  RoadmapVisualizationData
} from '../../domain/roadmap-planning-types';
import { SectionConfidence } from '../../domain/ai-types';
import {
  ROADMAP_GENERATION_SYSTEM_PROMPT,
  REQUIREMENTS_PARSING_PROMPT,
  formatRequirementsForPrompt,
  formatConstraintsForPrompt
} from './prompts/RoadmapPrompts';

// Zod schemas for AI structured output
const RequirementParseSchema = z.object({
  requirements: z.array(z.object({
    id: z.string(),
    title: z.string(),
    description: z.string(),
    priority: z.enum(['critical', 'high', 'medium', 'low']),
    estimatedComplexity: z.number().min(1).max(10),
    category: z.string()
  }))
});

const RoadmapStructureSchema = z.object({
  phases: z.array(z.object({
    id: z.string(),
    name: z.string(),
    description: z.string(),
    objectives: z.array(z.string()),
    durationWeeks: z.number(),
    requirementIds: z.array(z.string())
  })),
  milestones: z.array(z.object({
    id: z.string(),
    title: z.string(),
    description: z.string(),
    phaseId: z.string(),
    weekNumber: z.number(),
    deliverables: z.array(z.string()),
    dependencies: z.array(z.string()),
    confidence: z.number().min(0).max(1)
  })),
  reasoning: z.string()
});

export class RoadmapAIService {
  private aiFactory: AIServiceFactory;
  private estimationCalibrator: EstimationCalibrator;

  constructor(estimationCalibrator?: EstimationCalibrator) {
    this.aiFactory = AIServiceFactory.getInstance();
    this.estimationCalibrator = estimationCalibrator || new EstimationCalibrator();
  }

  /**
   * Generate a complete roadmap from requirements (AI-13)
   */
  async generateRoadmap(input: RoadmapGenerationInput): Promise<GeneratedRoadmap> {
    // 1. Parse requirements if string
    const requirements = typeof input.requirements === 'string'
      ? await this.parseRequirements(input.requirements)
      : input.requirements;

    // 2. Estimate effort for each requirement
    const estimatedRequirements = this.estimateRequirements(requirements);

    // 3. Calculate timeline using velocity
    const velocity = input.constraints?.velocity ?? 20;
    const sprintWeeks = input.constraints?.sprintDurationWeeks ?? 2;
    const bufferFactor = 1.2; // 20% buffer

    const totalPoints = estimatedRequirements.reduce((sum, r) => sum + r.estimatedPoints, 0);
    const sprints = Math.ceil((totalPoints * bufferFactor) / velocity);
    const totalWeeks = sprints * sprintWeeks;

    // 4. Generate roadmap structure with AI (AI-14: phase sequencing)
    const roadmapStructure = await this.generateRoadmapStructure(
      estimatedRequirements,
      input.constraints,
      totalWeeks
    );

    // 5. Calculate milestone dates from velocity (AI-15: milestone estimation)
    const startDate = new Date();
    const roadmap = this.calculateMilestoneDates(
      roadmapStructure,
      startDate,
      velocity,
      sprintWeeks
    );

    // 6. Add confidence scoring
    roadmap.confidence = this.calculateConfidence(requirements, roadmapStructure);

    return roadmap;
  }

  /**
   * Parse text requirements into structured format
   */
  private async parseRequirements(text: string): Promise<RequirementItem[]> {
    const model = this.aiFactory.getModel('main') || this.aiFactory.getBestAvailableModel();

    if (!model) {
      // Fallback: split by lines and create basic requirements
      return text.split('\n')
        .filter(line => line.trim())
        .map((line, i) => ({
          id: `REQ-${String(i + 1).padStart(3, '0')}`,
          title: line.trim(),
          priority: 'medium' as const
        }));
    }

    try {
      const result = await generateObject({
        model,
        system: REQUIREMENTS_PARSING_PROMPT,
        prompt: text,
        schema: RequirementParseSchema,
        temperature: 0.3
      });

      return result.object.requirements.map(r => ({
        id: r.id,
        title: r.title,
        description: r.description,
        priority: r.priority,
        estimatedPoints: complexityToPoints(r.estimatedComplexity as any),
        category: r.category
      }));
    } catch (error) {
      // Fallback on error
      return text.split('\n')
        .filter(line => line.trim())
        .map((line, i) => ({
          id: `REQ-${String(i + 1).padStart(3, '0')}`,
          title: line.trim(),
          priority: 'medium' as const
        }));
    }
  }

  /**
   * Estimate effort for requirements using EstimationCalibrator
   */
  private estimateRequirements(
    requirements: RequirementItem[]
  ): Array<RequirementItem & { estimatedPoints: number }> {
    return requirements.map(req => {
      // Use existing points or estimate from priority
      const points = req.estimatedPoints || this.estimateFromPriority(req.priority);
      return { ...req, estimatedPoints: points };
    });
  }

  private estimateFromPriority(priority?: string): number {
    // Higher priority often correlates with higher complexity
    switch (priority) {
      case 'critical': return 8;
      case 'high': return 5;
      case 'medium': return 3;
      case 'low': return 2;
      default: return 3;
    }
  }

  /**
   * Generate roadmap structure using AI (phases and milestones)
   */
  private async generateRoadmapStructure(
    requirements: Array<RequirementItem & { estimatedPoints: number }>,
    constraints: RoadmapGenerationInput['constraints'],
    totalWeeks: number
  ): Promise<z.infer<typeof RoadmapStructureSchema>> {
    const model = this.aiFactory.getModel('prd') || this.aiFactory.getBestAvailableModel();

    if (!model) {
      return this.getFallbackRoadmapStructure(requirements, totalWeeks);
    }

    try {
      const prompt = `Generate a roadmap for the following requirements:

${formatRequirementsForPrompt(requirements)}
${formatConstraintsForPrompt(constraints)}

Total estimated timeline: ${totalWeeks} weeks

Create logical phases with milestones. Use weekNumber to indicate when each milestone should be completed (1 = first week, ${totalWeeks} = last week).`;

      const result = await generateObject({
        model,
        system: ROADMAP_GENERATION_SYSTEM_PROMPT,
        prompt,
        schema: RoadmapStructureSchema,
        temperature: 0.5
      });

      return result.object;
    } catch (error) {
      return this.getFallbackRoadmapStructure(requirements, totalWeeks);
    }
  }

  /**
   * Calculate milestone dates from velocity (algorithmic, not AI)
   */
  private calculateMilestoneDates(
    structure: z.infer<typeof RoadmapStructureSchema>,
    startDate: Date,
    velocity: number,
    sprintWeeks: number
  ): GeneratedRoadmap {
    const phases: RoadmapPhase[] = structure.phases.map((phase, i) => ({
      id: phase.id,
      name: phase.name,
      description: phase.description,
      objectives: phase.objectives,
      durationWeeks: phase.durationWeeks,
      startWeek: i === 0 ? 1 : structure.phases.slice(0, i).reduce((sum, p) => sum + p.durationWeeks, 1),
      endWeek: structure.phases.slice(0, i + 1).reduce((sum, p) => sum + p.durationWeeks, 0),
      milestones: structure.milestones.filter(m => m.phaseId === phase.id).map(m => m.id)
    }));

    const milestones: RoadmapMilestone[] = structure.milestones.map(m => {
      const targetDate = new Date(startDate);
      targetDate.setDate(targetDate.getDate() + (m.weekNumber * 7));

      return {
        id: m.id,
        title: m.title,
        description: m.description,
        phaseId: m.phaseId,
        targetDate: targetDate.toISOString().split('T')[0],
        deliverables: m.deliverables,
        dependencies: m.dependencies,
        confidence: m.confidence
      };
    });

    const dependencies: MilestoneDependency[] = structure.milestones.flatMap(m =>
      m.dependencies.map(dep => ({
        fromMilestoneId: dep,
        toMilestoneId: m.id,
        type: 'blocks' as const
      }))
    );

    const totalWeeks = phases.length > 0 ? phases[phases.length - 1].endWeek : 0;
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + (totalWeeks * 7));

    return {
      phases,
      milestones,
      dependencies,
      timeline: {
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        totalWeeks
      },
      confidence: {
        score: 70,
        tier: 'medium',
        factors: { inputCompleteness: 0.7, aiSelfAssessment: 0.7, patternMatch: 0.7 },
        reasoning: 'Generated from requirements with velocity-based dates'
      },
      reasoning: structure.reasoning
    };
  }

  /**
   * Generate visualization data for Gantt-style rendering (AI-16)
   */
  generateVisualizationData(roadmap: GeneratedRoadmap): RoadmapVisualizationData {
    const colors = ['#4299e1', '#48bb78', '#ed8936', '#9f7aea', '#ed64a6', '#38b2ac'];

    return {
      phases: roadmap.phases.map((phase, i) => ({
        id: phase.id,
        name: phase.name,
        startWeek: phase.startWeek,
        endWeek: phase.endWeek,
        color: colors[i % colors.length]
      })),
      milestones: roadmap.milestones.map(m => {
        const phase = roadmap.phases.find(p => p.id === m.phaseId);
        const weekNumber = phase ? Math.round((phase.startWeek + phase.endWeek) / 2) : 1;
        return {
          id: m.id,
          title: m.title,
          week: weekNumber,
          phaseId: m.phaseId
        };
      }),
      dependencies: roadmap.dependencies.map(d => ({
        from: d.fromMilestoneId,
        to: d.toMilestoneId
      })),
      totalWeeks: roadmap.timeline.totalWeeks
    };
  }

  /**
   * Fallback roadmap structure when AI unavailable
   */
  private getFallbackRoadmapStructure(
    requirements: Array<RequirementItem & { estimatedPoints: number }>,
    totalWeeks: number
  ): z.infer<typeof RoadmapStructureSchema> {
    // Group requirements into 3-4 phases based on count
    const numPhases = Math.min(4, Math.max(2, Math.ceil(requirements.length / 5)));
    const reqsPerPhase = Math.ceil(requirements.length / numPhases);
    const weeksPerPhase = Math.ceil(totalWeeks / numPhases);

    const phases = [];
    const milestones = [];

    for (let i = 0; i < numPhases; i++) {
      const phaseReqs = requirements.slice(i * reqsPerPhase, (i + 1) * reqsPerPhase);
      const phaseId = `phase-${i + 1}`;

      phases.push({
        id: phaseId,
        name: `Phase ${i + 1}`,
        description: `Implementation phase ${i + 1}`,
        objectives: phaseReqs.slice(0, 3).map(r => r.title),
        durationWeeks: weeksPerPhase,
        requirementIds: phaseReqs.map(r => r.id || '')
      });

      milestones.push({
        id: `milestone-${i + 1}`,
        title: `Phase ${i + 1} Complete`,
        description: `Completion of phase ${i + 1} deliverables`,
        phaseId,
        weekNumber: (i + 1) * weeksPerPhase,
        deliverables: phaseReqs.slice(0, 3).map(r => r.title),
        dependencies: i > 0 ? [`milestone-${i}`] : [],
        confidence: 0.6
      });
    }

    return {
      phases,
      milestones,
      reasoning: 'Fallback: grouped requirements into sequential phases'
    };
  }

  private calculateConfidence(
    requirements: RequirementItem[],
    structure: any
  ): SectionConfidence {
    // More requirements = more data = higher confidence
    const inputScore = Math.min(1, requirements.length / 10);
    // More phases = more structured = higher confidence
    const patternScore = structure.phases?.length >= 3 ? 0.8 : 0.5;

    const factors = {
      inputCompleteness: inputScore,
      aiSelfAssessment: 0.7,
      patternMatch: patternScore
    };

    const score = calculateWeightedScore(factors);

    return {
      score,
      tier: getConfidenceTier(score),
      factors,
      reasoning: `Based on ${requirements.length} requirements across ${structure.phases?.length || 0} phases`
    };
  }
}
```

Ensure the service:
1. Parses text requirements into structured format
2. Uses EstimationCalibrator for effort estimation
3. Generates phases with proper sequencing (AI-14)
4. Calculates dates algorithmically from velocity (AI-15)
5. Provides visualization data for rendering (AI-16)
6. Has fallback behavior when AI unavailable
  </action>
  <verify>npx tsc --noEmit src/services/ai/RoadmapAIService.ts</verify>
  <done>RoadmapAIService generates roadmaps with phases, milestones, velocity-based dates, and visualization data</done>
</task>

</tasks>

<verification>
1. All new services compile without TypeScript errors
2. Services use existing Phase 9 patterns (EstimationCalibrator, ConfidenceScorer)
3. Milestone dates are calculated algorithmically, not AI-generated
4. Visualization data structure matches requirements for Gantt rendering
5. AI fallback behavior works when model unavailable
</verification>

<success_criteria>
1. RoadmapAIService.generateRoadmap creates structured roadmap from requirements
2. Phase sequencing follows logical order (foundation -> core -> advanced)
3. Milestone dates are velocity-grounded (calculated from scope + velocity + buffer)
4. RoadmapAIService.generateVisualizationData produces Gantt-ready data
5. All services have fallback behavior for AI unavailability
6. Confidence scores included in roadmap output
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-sprint-roadmap-planning/10-03-SUMMARY.md`
</output>
